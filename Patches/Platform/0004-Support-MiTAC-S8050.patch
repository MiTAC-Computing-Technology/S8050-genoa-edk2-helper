From 2feeab0f9c06023b038a11a92ef8fef178170802 Mon Sep 17 00:00:00 2001
From: Samba Chi <samba.chi@mitaccomputing.com>
Date: Wed, 20 Nov 2024 12:13:49 +0800
Subject: [PATCH 1/2] Support MiTAC S8050

---
 .../BiosDirL10_Typex68_0_0_0_ApcbRec.bin      |  Bin 0 -> 20480 bytes
 .../BiosDirL10_Typex68_0_8_0_ApcbRec.bin      |  Bin 0 -> 1624 bytes
 .../BiosDirL10_Typex68_0_9_0_ApcbRec.bin      |  Bin 0 -> 1184 bytes
 .../BiosDirL20_Typex60_0_0_0_Apcb.bin         |  Bin 0 -> 4096 bytes
 .../BiosDirL20_Typex60_0_1_0_Apcb.bin         |  Bin 0 -> 4096 bytes
 .../BiosDirL20_Typex68_0_0_0_ApcbRec.bin      |  Bin 0 -> 20480 bytes
 .../BiosDirL20_Typex68_0_8_0_ApcbRec.bin      |  Bin 0 -> 1624 bytes
 .../BiosDirL20_Typex68_0_9_0_ApcbRec.bin      |  Bin 0 -> 1184 bytes
 .../Include/AgesaInc/AgesaExt.dxe.inc.fdf     |   13 +
 .../Include/AgesaInc/AgesaExt.inc.dsc         |   13 +
 .../Include/AgesaInc/AgesaExt.pei.inc.fdf     |   13 +
 .../S8050BoardPkg/Include/Dsc/Smbios.dsc      |   95 +
 .../Include/Fdf/FlashMapInclude.fdf           |  169 ++
 .../S8050BoardPkg/Include/Fdf/Smbios.fdf      |    8 +
 .../Library/SmbiosMiscLib/SmbiosMiscLib.inf   |   31 +
 .../SmbiosType41OnboardDevExtInfo.c           |   80 +
 .../SmbiosType8PortConnectorInfo.c            |  206 ++
 .../Universal/DisplayEngineDxe/InputHandler.c | 1733 +++++++++++++++++
 GenoaOpenBoardPkg/S8050BoardPkg/Project.dsc   | 1370 +++++++++++++
 GenoaOpenBoardPkg/S8050BoardPkg/Project.fdf   |  821 ++++++++
 .../S8050BoardPkg/PspDataGenoa.xml            |  101 +
 .../support/SupportedBuilds.json              |   15 +
 .../S8050BoardPkg/support/__init__.py         |    6 +
 .../S8050BoardPkg/support/projectpostbuild.py |   30 +
 .../S8050BoardPkg/support/projectprebuild.py  |   16 +
 .../BasePlatformHookLibAST2600.c              |   97 +
 .../BasePlatformHookLibAST2600.inf            |   46 +
 27 files changed, 4863 insertions(+)
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL10_Typex68_0_0_0_ApcbRec.bin
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL10_Typex68_0_8_0_ApcbRec.bin
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL10_Typex68_0_9_0_ApcbRec.bin
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex60_0_0_0_Apcb.bin
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex60_0_1_0_Apcb.bin
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex68_0_0_0_ApcbRec.bin
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex68_0_8_0_ApcbRec.bin
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex68_0_9_0_ApcbRec.bin
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.dxe.inc.fdf
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.inc.dsc
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.pei.inc.fdf
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Include/Dsc/Smbios.dsc
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Include/Fdf/FlashMapInclude.fdf
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Include/Fdf/Smbios.fdf
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosMiscLib.inf
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosType41OnboardDevExtInfo.c
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosType8PortConnectorInfo.c
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Override/edk2/MdeModulePkg/Universal/DisplayEngineDxe/InputHandler.c
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Project.dsc
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/Project.fdf
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/PspDataGenoa.xml
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/support/SupportedBuilds.json
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/support/__init__.py
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/support/projectpostbuild.py
 create mode 100644 GenoaOpenBoardPkg/S8050BoardPkg/support/projectprebuild.py
 create mode 100644 MiTACCommonPkg/Library/PlatformHookLib/BasePlatformHookLibAST2600/BasePlatformHookLibAST2600.c
 create mode 100644 MiTACCommonPkg/Library/PlatformHookLib/BasePlatformHookLibAST2600/BasePlatformHookLibAST2600.inf

diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL10_Typex68_0_0_0_ApcbRec.bin b/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL10_Typex68_0_0_0_ApcbRec.bin
new file mode 100644
index 0000000000000000000000000000000000000000..8f56150d39bfc5c40cbb63aa1b3de304cc6283ad
GIT binary patch
literal 20480
zcmeHN3sh9q8s6v3VHgx-c<3mgjp8F*V1o!EnGmS>NX2K;@_~_Lc1eqeWvF9fXqmbc
zgnKnLAEYFLVO}js^Hul`NmEhu=7TJa#1dTA-2LryjvN7jNvT!qY(49n|KI=K`#azM
z_t~47^K?X5sF|2Zu{R<A@h7Aixxe%Y3++mXo;VZ2MX@T2B}5T2TJhQ1kD*}^PY>!d
zC|oe;2}c{Jwj)F^_>v45gcu32SP0QEgA;KzLyoLr$dh#pH6)XvKsGS6Az2KyoEUG*
ziSas4jJM;&_$Hhf-;`tVdcw1KJ;$?nJ<qdvy@qG;dVy#0dK+Gh*J{LgTa6g6(}?kQ
z8Zo|!MvQN&5&7te$j3?I?=10mk@&kx{F_VsTS)v3691MG|5g%zH;KQy#9uG*car!!
zOZ;6V{;m@L<`VxF5`Tllzoo>#mBimo;_t4>5)A%CuVGUm&I`wD1RJfb&aO#QdxvI@
zdM9TW*XAt@EnB&{d$exz7*Xq0eg47uAs7Nkl=3-sU%ua;{i-EDCmODVVCYT)+2cms
z2e1opJZG_ouccVQe8T-c!4QH5C`Rlbg4SYjw9wr^uvpMoFhr2{tXiz+IF8W&v~xnt
zqMybLBgu*we1x45q==!mKrgLyQ6M9^-NX{ib{=9G!V_2Ovy9h>I7JX~mW_yuv?8vu
z716@8{?HGKU>Ht!Wmb&14^RXLGrcfw^|1v*0_%rX84>@}@91MbSuAd!%m?j`+Y-X_
z0+&QTqffbDEV})Yp7e^K*Xz;+8-85M@;Ehcp<a$bJNSI0E0`kY&`2-%F&-`j4?aoq
zQDDUy9%Zz}BjF+N_w-QSyL{j9$$t4>8$}O+zo&;h9_FE;Jjx!K9##3F<bivKU7N3Q
z^bl&*<Im)gp~HHqnI9%;USuwqC#BC?J&?zBtrv+$4Ly`&%JZW1DS4F9G3r|{_3?<Z
zqk3>v`9ZsUV1Xvk2bYou8q~)F&k$J;+z);9-uL{Fc-+&2RzI*bCXdIPP+mND@A)B<
z0B8B$WuFr3(*ycM&<i+L!n*X3c+}9t8XjfRI2cpr{)c!7HT6)=0qwp<u||*T`wQ-|
zdVVlH1g?f2e+3VoCP)(HsN8RB2tXamxvEbO)JM?En*5+VYUp7NkJ|FX8Xh>0glNp(
zbW9`8DEH0*Le=vG^MeaxAqR1fwfU^kr+U5^X`j%o#(6}j+HYzbvo_zO=JBBY20CCY
zr6x*WT|DGCAnqG_0OjY2QL>eKJZQg>`)UY}GO1sTCC7uOH9V}@Z!n%o8mlfnz@<8m
zN4eiL77whS3avSt(l^$%exNTn$eJT>tNR{CA3Au0)=%{@{|p}0*AMPfo@<~<vTO6v
zs(S@FE9Y%(`C{$*`6E0qhY!oc+Vvyn4EQQbeLNoZ`e`g4jdfm=^9efrmFG2Uc_2UN
zalXd+1i2^Afie%|&voTTZyKcJf!wGsKcw^8Bjr)sx@{m2K8bS1ekhl}LJ#%aD9!=)
zy{TIBQ92jKy7oQnFUooPGtO)5`!x03$kqzZ^MA*4qkJv_*7aO7N%avF@tkkSbIscC
zDbROg@ThCwlgFe(*C_Sr0UcyL9(LbrD33Bart&;ul5DGa)Uxj>bD@S9)M1St4atwX
zzNcuY9^hG*9u4JT&3+?ut4|NqTRSh-d{0pukFr|yu!e_VSjc{7q1_m<-_T!(*z=95
z+{D+(*GaT+IuLEXT0LxW=ZdmJJWucsB||6MVjstCWt)DhO6x^iFf1Y=2q#tJi~UuN
zcfXCcxWw@U!;(hgUv)oq^I!Uq{8Jy$ULIf8w@Od({&h@G!I1WV_SN;1`-674ME(1Q
z^$XWZ@1!iIUaf&Mnkmv^Wch#}40$M^;cRUMTl$llRMyycAr*XuW`lhxUn;&WAy+j3
zuhO3=tB2uEM+_M_n3%+OWCH1V9e>1{C|#b@83mf3#$7|$Pnc$>qZ-7QeiS7D?c2_0
z)Dq6FXXw!@+#de<)1GkzcFQ>I0h~S7%aZ~rn0n+1*x5OmzOe7C&FTre@X&UKKW?aC
zILU5FU-;vObm)h;@E$ux0T1SRN5cQ@l~>0BqrP^10sf=crcQ+2zp}+7;L>DYhWmqD
zCd2-Xyf~Qx`8@W-zktm@m^}r!#2or6FwhtfkGRgQFHHj$+`KXk{**5!B*EVKe!vW1
zOw4Puf#v0c=K`O5H!TIYCnSF!1+uj`c@eN^iCZdA7j0OE`lN+}(_t5F3|I-Ao`?5h
z2&wc~u?BXj`}_1g9;$iPvTWFw{Jvs1(q`Na_}9$c@)`UG);^aH?0$CB0bt%+$tQvK
zQ%;=%wzc>bBi^pr`SY;Hxg5R-d@5kU6=3m+k}IfhJAl6md*8*Oc$ATYE8k{Vrk{Qj
zw&yMW7VyS`#9x3zyM1;W?Lx}@@4)VUBb8wVclLMqiHRc_LRG$OTyPi3PWr!h+{T7t
z^ou>TNY>!tQ*}r{W8^v=?Bn*icC;BOeJcz{J8~uOUA>N?-Gy}aDo{yRKNr+T_Xu`H
zyAm5sD+*-7xl64vz~wvNwqXN}&=|qP#XhSoaFy4sb`;15+j3dndHIF6?@aA)bSvAV
zAE6-I3*!{GzvxYY6r3sdMgp(jvCIU2+N}Jp=%-@cNq=DZvK#(rm*{RE2s<OXO%L4H
zNT1iAg#S0sa)x<HreN4#7V5(&kQPPpy@4G`5yQ$e0pYOYQq%gOpP((a{b6hQnS+4t
z#a#x&zxr1EQ1Dsa`_tj*@A<^BBPfuyHtj|N|J}v;S>QW`hesp+i=}-cp+n}ed69^J
z>y`J$P#{<AQleq+{y2Uj^p4w~&hWYCe~y9Q<B1b5!ykC;8MZD`?}o<V{&%L>B~T!-
zhdLz!y9PwRfw+Xno_Z6w-sjK^`15By#@2&Nx!WA@IN%pG2mX_Js~J|tO-y#A_B03A
zw^8qy;F*H<MTOf^D3I@cnl1qEj>9`GME$8V0~vPCU%L?ewC)EOdd=OjD3{tjCKabq
zAO|~?EJM3B0-p}P=dSf+>uc-!P3+aasbeaZBW|GM8!Is0%QyG3b(aymcs2YtyuZ%`
z7P_tc5a{yk<_|I6t`UhFfFqYBZh)T)8n6-V`=?#ahJW4BzMC=LEr(f~VY^o5Z3b`W
zf!moqB`7whfZA;@4Fz4&D|=fm+WVPb*n;>Dj;UJ^UlN;~M}fp?TW$q@RQU=+zo6)C
zutN<o3`<hp+m3dh_R8FjcDFAN+ll(SlLzFZ-?Zqs-SE4XSoSbI1|{sp0&yw0y$}Aw
ztv}mOft=gD=Mb=+KJy6tKP7TUkzeH4`D3t;d)R#q)BMVcuQ6Uh?7Tu?{O4a5!e20c
z=Qqgrex^<AIkP{j@D#=i9m=0Z`|?-Yoko3Tdf{mb<b%F@&j8Ov{`VYkV42Sa^w)8x
z`6Bci(8lY3@Nerp>MGiQ{M~P*=uaEC_XqfYE-PkO`o7C`)HhvPdL4eJkcB@3gR_%w
zqCX#3hjQS++~@D0{jfdr?ouFw$}8b!o7e>k@;<h+#YV0-U5VeWvKalT-_SG88@4dU
z2iqO_>HJM!GsUsHz7HHvvFpt#PorMH?dnjSK-a5oZX{lmS-jBqC19|pAr|$woj=V0
z_Kb~Nfqtit%=sjO;&+}a_rbq9@EV(kIWNsTf*m;j;=yCUT_s~rAwF1}a29bDL)w<Y
zKGD(r2lQWX>67a?zk5%1D}(=Z|7pJ<uFKj@zrrRaftYEWe1B2lFZ0vMbi$>-tHU0?
zZ~hJkgw0wM<OqLg>SY7aloVs6M*)jXr*odDKQeA>d)f_o!hU!swCmX<y;~U_H|NW<
z-4OrgjO9<!YJL2$8NCocASY}X{G)Tbu$PE7MaM*<zjt=G8-w;ouTO|V{e+V-6M=r$
z4^9G>c<g!&nB8(%Jo*VP|1lBq*EbHCPR$GZUy7PZyP4J8Vcu-iFX4O^BfihE(Mw*S
z_VDg|KLpRLoKZQf-&HX=h@07a{uYd1l%DXpz7u`N_>E@!Q6CahaiBLX8~bhl3ikM4
z=N!%z==#;QKLNYhHBAxyM#rK#dGI7`uj4^1U!UA(cOLz1Y2|+z{$0&?{EBfF-6~-F
z-VBFPEYA?57F7XN0aXE20aXE20aXE20aXE20aXE20aXE20aXE20aXE20aXE20aXE2
f0aXE20aXE20aXE20aXE20aXE20aby2vI74HDW#t#

literal 0
HcmV?d00001

diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL10_Typex68_0_8_0_ApcbRec.bin b/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL10_Typex68_0_8_0_ApcbRec.bin
new file mode 100644
index 0000000000000000000000000000000000000000..fd1b228e43b27f5d845a5d2ca1e2853d54b16e07
GIT binary patch
literal 1624
zcmeH{X-HII6o$_o$0ahmsX1y3ZWzU+gC>Ot>WsU&myV#JK^BD+xs^rBKhe_2D5G-8
zRJ3Hq0@JcgO<bB3RL0aq%r(-=r8E(y@12OI{`I@=k9ofLJ?A_3yXT%e-r+Lo1(J~5
zfT-AwsGfemd}UG>BA!f%xCCuTqw&&7k?XAgb}5yGd;9qL+vtgS;@D;z0g;|aMLZ+B
zcp{BPyZZn0&vsy6Sa2vwe#}Rm9&3X{I~XM3jCdjDgXukNdYBeMrwx@EqFEjDlNsQ+
zYkM_#z)Up?#)pqhf+XQEU^;a;QgXlQbj^ieB&qV!ssQ6S`6!3S?MGZ(&4i4@$!X?D
zSbP<24VoEO*@7jtN_z%+>o6(?I|diT*jHA6U1G%eY^uoxdikE(4f$<7yo`Y?`ci#B
zN9xnky~Z#Q+CXqF1iX_|9BRo}yqFq+2Q1aM+YkSylW7c?-J_DDUQ@nrEY4frofQlJ
zY>em(IR5SMWyHG;mAUw+@}?$p;h%_Gz6JlI_<cEak9A=MC>15uf=d&T4Qm+9M>Nf-
zdp9Jl#fnk2<!LJe+41GCvHw##*M)PnR`v8FPZ}W@fM4R*GRQ!Kv5$vA$A$}|=tI!f
z?e7q;-4Q(nuFapGWuOgSxpQE@@7SC^<D7ox65_$igDa>T*_^e?z}}zWkM}2_0-ZT%
zu&CsGSSQ~UX>8cv8i_no#LzDD$Gt&Mdr>mze1GQDULku<(<cSc9?2=Uk?-@|`yu=>
z`@)y-8%N^%;d>gS4M8u5*-k_EI&S))VFwf+wf+n}5SZ}=ai`J;U!h4Nq-mXVCHNl`
zWKt$^H*$<HyXW)V*F#IMO^85e<EU-$6>USipo0{$NKmeHih`g0!Y&T%noUfApQuhc
z1iH?49sx%-H=YEmEhAHLd(VZLbmVVbmvs^PD!20r;_8)vLg=X7Efwf*l_FZ9ty7ew
qfNyfzq!qd{pspQUG;-(#_0*keu*S-50?b?NSV2CXlV|w(U492R@C*<D

literal 0
HcmV?d00001

diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL10_Typex68_0_9_0_ApcbRec.bin b/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL10_Typex68_0_9_0_ApcbRec.bin
new file mode 100644
index 0000000000000000000000000000000000000000..74bd92d0b992c3b3bee87b074f4b783d5b2d5389
GIT binary patch
literal 1184
zcmZ<^aCT~7Fko1~!oaY^l!2j>0TsA9I~g%B2rvjSFfb;7rT+hSKvEKc#3q&L<Q(AW
r>+0*yA}+wd2-K_qbOVcc9D@Lm1_BNShX4P;tWjb#1V%$(M1}wWbP){!

literal 0
HcmV?d00001

diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex60_0_0_0_Apcb.bin b/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex60_0_0_0_Apcb.bin
new file mode 100644
index 0000000000000000000000000000000000000000..58a731c9b23b2fd6ddad11abafed4bd9e49a66f9
GIT binary patch
literal 4096
zcmeH`YfwyK7{{M;+HT`^Y_iE^x|j^JYHb>(F;ndpl9D22Fk#AV8irQHxO{6w84Q|8
zE=AGorkUJwsWgd|nU!6NX|}X6S|b)|npy9Ejj??5#TVy%IKTJ*Jn#FQ_x-=miAq$f
z_K|{8-H0}f(9jL~{fSYlltcnaiMVt}%5INznv&`?{@bBSofs88cb=b%OdyUe_T!0M
zWO@=9*&`6y?T(T7`fnXrvM4Tr6hHdox(l;G;b;uvIS)aC{$P4G>mH^h(3*}icbL`k
z(UJqc4t-DsuJY2G!Ig>K7LXJi8qBE<N0+!?bz1x5(UMegaEM1cT59qIe7;i|>Lp=(
zm8BVj3ARTmzM$9eN`LTdtuBy(UQRa4!It(<a;z)6aa`fSc)Pb=2|aMZ7>4=H20_h0
zW81Q$!60gLFudA57TS&96AzxwFHP`aEVX4X#sSZ}1}sIqC|J4-JYdkLqF(*cm^AFS
z{7GIK;=7m0c7d<ItviJL6L(z!eyYM=O9A3rRtyv){$BpJ9NOSpauHO?GHb!FJxO(*
zjAJ_O4XArAUeh>^Q9tok69WYZ<&UwxsnTFVUbUEi0eyCEV><)2r(Jsm2G#8|<NOOI
zP3=Oyc3Mg=IPB;fD+7&=Ea(SKG2Q*HjQy^;Uy+Z~tr<k!q=vj926k`!ANR)7NvHd-
z8(YCeGY6lavHOLw>9RT7<j~5Go1?&pKv@<Ta=CBELJ2#c^yW$EIa%9IVSe<TsH=!~
z2bSDN{BGw;6XFqWnhxlJMgDJ~p9YP8XJ;FfZ}j~D{USE!GxEXbuY7?fg@ish?JIrW
zCO(&Pi93<+fu7x47(NPGb*x7Qh73=hg1EN1V<z+htvU%z)deRbe&Alf3b56>Ivw%V
z#>@;b)cSBe*g4_uR<Oz^DI1@U_|&%@^Swvp?T0?XO+Sphad3VKbn>jmi}1Hno1%5p
zIg_bHykORhn&S0*&d8l3n-H&<fBgYy^O*b;bTK|Og4N@~dcZ<k%OKX_yaL0||594n
zrD%R;_AJcIkT>fsYbWqVlSx_RJ+-T;#=1Nv+_6S{i4KSkhz^Jjhz^Jjhz^Jj{BsAs
E1C6#FkpKVy

literal 0
HcmV?d00001

diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex60_0_1_0_Apcb.bin b/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex60_0_1_0_Apcb.bin
new file mode 100644
index 0000000000000000000000000000000000000000..9b21650ce9a152d9c3eee02a106795cdf3d0e61e
GIT binary patch
literal 4096
zcmZ<^aCT~7Fko1~!oXml^q)bH0TsA9I~g%B2rvjSFfb;7rT+hSKvEKc#3q&L<Q(AW
z>+0*yA}+wd2-K_qbOVcc9D@Lm1_BNShX4P;tWjb#1V%$(M1}zGlf+GOhpxM>oF_R?
zf?dV3u;!F(z{~rQUB6DH%;D{rIU)mP)YGFOFd71*Aut*OqaiRF0;3@?8UmvsKxPO4
E0J~ruJOBUy

literal 0
HcmV?d00001

diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex68_0_0_0_ApcbRec.bin b/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex68_0_0_0_ApcbRec.bin
new file mode 100644
index 0000000000000000000000000000000000000000..8f56150d39bfc5c40cbb63aa1b3de304cc6283ad
GIT binary patch
literal 20480
zcmeHN3sh9q8s6v3VHgx-c<3mgjp8F*V1o!EnGmS>NX2K;@_~_Lc1eqeWvF9fXqmbc
zgnKnLAEYFLVO}js^Hul`NmEhu=7TJa#1dTA-2LryjvN7jNvT!qY(49n|KI=K`#azM
z_t~47^K?X5sF|2Zu{R<A@h7Aixxe%Y3++mXo;VZ2MX@T2B}5T2TJhQ1kD*}^PY>!d
zC|oe;2}c{Jwj)F^_>v45gcu32SP0QEgA;KzLyoLr$dh#pH6)XvKsGS6Az2KyoEUG*
ziSas4jJM;&_$Hhf-;`tVdcw1KJ;$?nJ<qdvy@qG;dVy#0dK+Gh*J{LgTa6g6(}?kQ
z8Zo|!MvQN&5&7te$j3?I?=10mk@&kx{F_VsTS)v3691MG|5g%zH;KQy#9uG*car!!
zOZ;6V{;m@L<`VxF5`Tllzoo>#mBimo;_t4>5)A%CuVGUm&I`wD1RJfb&aO#QdxvI@
zdM9TW*XAt@EnB&{d$exz7*Xq0eg47uAs7Nkl=3-sU%ua;{i-EDCmODVVCYT)+2cms
z2e1opJZG_ouccVQe8T-c!4QH5C`Rlbg4SYjw9wr^uvpMoFhr2{tXiz+IF8W&v~xnt
zqMybLBgu*we1x45q==!mKrgLyQ6M9^-NX{ib{=9G!V_2Ovy9h>I7JX~mW_yuv?8vu
z716@8{?HGKU>Ht!Wmb&14^RXLGrcfw^|1v*0_%rX84>@}@91MbSuAd!%m?j`+Y-X_
z0+&QTqffbDEV})Yp7e^K*Xz;+8-85M@;Ehcp<a$bJNSI0E0`kY&`2-%F&-`j4?aoq
zQDDUy9%Zz}BjF+N_w-QSyL{j9$$t4>8$}O+zo&;h9_FE;Jjx!K9##3F<bivKU7N3Q
z^bl&*<Im)gp~HHqnI9%;USuwqC#BC?J&?zBtrv+$4Ly`&%JZW1DS4F9G3r|{_3?<Z
zqk3>v`9ZsUV1Xvk2bYou8q~)F&k$J;+z);9-uL{Fc-+&2RzI*bCXdIPP+mND@A)B<
z0B8B$WuFr3(*ycM&<i+L!n*X3c+}9t8XjfRI2cpr{)c!7HT6)=0qwp<u||*T`wQ-|
zdVVlH1g?f2e+3VoCP)(HsN8RB2tXamxvEbO)JM?En*5+VYUp7NkJ|FX8Xh>0glNp(
zbW9`8DEH0*Le=vG^MeaxAqR1fwfU^kr+U5^X`j%o#(6}j+HYzbvo_zO=JBBY20CCY
zr6x*WT|DGCAnqG_0OjY2QL>eKJZQg>`)UY}GO1sTCC7uOH9V}@Z!n%o8mlfnz@<8m
zN4eiL77whS3avSt(l^$%exNTn$eJT>tNR{CA3Au0)=%{@{|p}0*AMPfo@<~<vTO6v
zs(S@FE9Y%(`C{$*`6E0qhY!oc+Vvyn4EQQbeLNoZ`e`g4jdfm=^9efrmFG2Uc_2UN
zalXd+1i2^Afie%|&voTTZyKcJf!wGsKcw^8Bjr)sx@{m2K8bS1ekhl}LJ#%aD9!=)
zy{TIBQ92jKy7oQnFUooPGtO)5`!x03$kqzZ^MA*4qkJv_*7aO7N%avF@tkkSbIscC
zDbROg@ThCwlgFe(*C_Sr0UcyL9(LbrD33Bart&;ul5DGa)Uxj>bD@S9)M1St4atwX
zzNcuY9^hG*9u4JT&3+?ut4|NqTRSh-d{0pukFr|yu!e_VSjc{7q1_m<-_T!(*z=95
z+{D+(*GaT+IuLEXT0LxW=ZdmJJWucsB||6MVjstCWt)DhO6x^iFf1Y=2q#tJi~UuN
zcfXCcxWw@U!;(hgUv)oq^I!Uq{8Jy$ULIf8w@Od({&h@G!I1WV_SN;1`-674ME(1Q
z^$XWZ@1!iIUaf&Mnkmv^Wch#}40$M^;cRUMTl$llRMyycAr*XuW`lhxUn;&WAy+j3
zuhO3=tB2uEM+_M_n3%+OWCH1V9e>1{C|#b@83mf3#$7|$Pnc$>qZ-7QeiS7D?c2_0
z)Dq6FXXw!@+#de<)1GkzcFQ>I0h~S7%aZ~rn0n+1*x5OmzOe7C&FTre@X&UKKW?aC
zILU5FU-;vObm)h;@E$ux0T1SRN5cQ@l~>0BqrP^10sf=crcQ+2zp}+7;L>DYhWmqD
zCd2-Xyf~Qx`8@W-zktm@m^}r!#2or6FwhtfkGRgQFHHj$+`KXk{**5!B*EVKe!vW1
zOw4Puf#v0c=K`O5H!TIYCnSF!1+uj`c@eN^iCZdA7j0OE`lN+}(_t5F3|I-Ao`?5h
z2&wc~u?BXj`}_1g9;$iPvTWFw{Jvs1(q`Na_}9$c@)`UG);^aH?0$CB0bt%+$tQvK
zQ%;=%wzc>bBi^pr`SY;Hxg5R-d@5kU6=3m+k}IfhJAl6md*8*Oc$ATYE8k{Vrk{Qj
zw&yMW7VyS`#9x3zyM1;W?Lx}@@4)VUBb8wVclLMqiHRc_LRG$OTyPi3PWr!h+{T7t
z^ou>TNY>!tQ*}r{W8^v=?Bn*icC;BOeJcz{J8~uOUA>N?-Gy}aDo{yRKNr+T_Xu`H
zyAm5sD+*-7xl64vz~wvNwqXN}&=|qP#XhSoaFy4sb`;15+j3dndHIF6?@aA)bSvAV
zAE6-I3*!{GzvxYY6r3sdMgp(jvCIU2+N}Jp=%-@cNq=DZvK#(rm*{RE2s<OXO%L4H
zNT1iAg#S0sa)x<HreN4#7V5(&kQPPpy@4G`5yQ$e0pYOYQq%gOpP((a{b6hQnS+4t
z#a#x&zxr1EQ1Dsa`_tj*@A<^BBPfuyHtj|N|J}v;S>QW`hesp+i=}-cp+n}ed69^J
z>y`J$P#{<AQleq+{y2Uj^p4w~&hWYCe~y9Q<B1b5!ykC;8MZD`?}o<V{&%L>B~T!-
zhdLz!y9PwRfw+Xno_Z6w-sjK^`15By#@2&Nx!WA@IN%pG2mX_Js~J|tO-y#A_B03A
zw^8qy;F*H<MTOf^D3I@cnl1qEj>9`GME$8V0~vPCU%L?ewC)EOdd=OjD3{tjCKabq
zAO|~?EJM3B0-p}P=dSf+>uc-!P3+aasbeaZBW|GM8!Is0%QyG3b(aymcs2YtyuZ%`
z7P_tc5a{yk<_|I6t`UhFfFqYBZh)T)8n6-V`=?#ahJW4BzMC=LEr(f~VY^o5Z3b`W
zf!moqB`7whfZA;@4Fz4&D|=fm+WVPb*n;>Dj;UJ^UlN;~M}fp?TW$q@RQU=+zo6)C
zutN<o3`<hp+m3dh_R8FjcDFAN+ll(SlLzFZ-?Zqs-SE4XSoSbI1|{sp0&yw0y$}Aw
ztv}mOft=gD=Mb=+KJy6tKP7TUkzeH4`D3t;d)R#q)BMVcuQ6Uh?7Tu?{O4a5!e20c
z=Qqgrex^<AIkP{j@D#=i9m=0Z`|?-Yoko3Tdf{mb<b%F@&j8Ov{`VYkV42Sa^w)8x
z`6Bci(8lY3@Nerp>MGiQ{M~P*=uaEC_XqfYE-PkO`o7C`)HhvPdL4eJkcB@3gR_%w
zqCX#3hjQS++~@D0{jfdr?ouFw$}8b!o7e>k@;<h+#YV0-U5VeWvKalT-_SG88@4dU
z2iqO_>HJM!GsUsHz7HHvvFpt#PorMH?dnjSK-a5oZX{lmS-jBqC19|pAr|$woj=V0
z_Kb~Nfqtit%=sjO;&+}a_rbq9@EV(kIWNsTf*m;j;=yCUT_s~rAwF1}a29bDL)w<Y
zKGD(r2lQWX>67a?zk5%1D}(=Z|7pJ<uFKj@zrrRaftYEWe1B2lFZ0vMbi$>-tHU0?
zZ~hJkgw0wM<OqLg>SY7aloVs6M*)jXr*odDKQeA>d)f_o!hU!swCmX<y;~U_H|NW<
z-4OrgjO9<!YJL2$8NCocASY}X{G)Tbu$PE7MaM*<zjt=G8-w;ouTO|V{e+V-6M=r$
z4^9G>c<g!&nB8(%Jo*VP|1lBq*EbHCPR$GZUy7PZyP4J8Vcu-iFX4O^BfihE(Mw*S
z_VDg|KLpRLoKZQf-&HX=h@07a{uYd1l%DXpz7u`N_>E@!Q6CahaiBLX8~bhl3ikM4
z=N!%z==#;QKLNYhHBAxyM#rK#dGI7`uj4^1U!UA(cOLz1Y2|+z{$0&?{EBfF-6~-F
z-VBFPEYA?57F7XN0aXE20aXE20aXE20aXE20aXE20aXE20aXE20aXE20aXE20aXE2
f0aXE20aXE20aXE20aXE20aXE20aby2vI74HDW#t#

literal 0
HcmV?d00001

diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex68_0_8_0_ApcbRec.bin b/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex68_0_8_0_ApcbRec.bin
new file mode 100644
index 0000000000000000000000000000000000000000..fd1b228e43b27f5d845a5d2ca1e2853d54b16e07
GIT binary patch
literal 1624
zcmeH{X-HII6o$_o$0ahmsX1y3ZWzU+gC>Ot>WsU&myV#JK^BD+xs^rBKhe_2D5G-8
zRJ3Hq0@JcgO<bB3RL0aq%r(-=r8E(y@12OI{`I@=k9ofLJ?A_3yXT%e-r+Lo1(J~5
zfT-AwsGfemd}UG>BA!f%xCCuTqw&&7k?XAgb}5yGd;9qL+vtgS;@D;z0g;|aMLZ+B
zcp{BPyZZn0&vsy6Sa2vwe#}Rm9&3X{I~XM3jCdjDgXukNdYBeMrwx@EqFEjDlNsQ+
zYkM_#z)Up?#)pqhf+XQEU^;a;QgXlQbj^ieB&qV!ssQ6S`6!3S?MGZ(&4i4@$!X?D
zSbP<24VoEO*@7jtN_z%+>o6(?I|diT*jHA6U1G%eY^uoxdikE(4f$<7yo`Y?`ci#B
zN9xnky~Z#Q+CXqF1iX_|9BRo}yqFq+2Q1aM+YkSylW7c?-J_DDUQ@nrEY4frofQlJ
zY>em(IR5SMWyHG;mAUw+@}?$p;h%_Gz6JlI_<cEak9A=MC>15uf=d&T4Qm+9M>Nf-
zdp9Jl#fnk2<!LJe+41GCvHw##*M)PnR`v8FPZ}W@fM4R*GRQ!Kv5$vA$A$}|=tI!f
z?e7q;-4Q(nuFapGWuOgSxpQE@@7SC^<D7ox65_$igDa>T*_^e?z}}zWkM}2_0-ZT%
zu&CsGSSQ~UX>8cv8i_no#LzDD$Gt&Mdr>mze1GQDULku<(<cSc9?2=Uk?-@|`yu=>
z`@)y-8%N^%;d>gS4M8u5*-k_EI&S))VFwf+wf+n}5SZ}=ai`J;U!h4Nq-mXVCHNl`
zWKt$^H*$<HyXW)V*F#IMO^85e<EU-$6>USipo0{$NKmeHih`g0!Y&T%noUfApQuhc
z1iH?49sx%-H=YEmEhAHLd(VZLbmVVbmvs^PD!20r;_8)vLg=X7Efwf*l_FZ9ty7ew
qfNyfzq!qd{pspQUG;-(#_0*keu*S-50?b?NSV2CXlV|w(U492R@C*<D

literal 0
HcmV?d00001

diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex68_0_9_0_ApcbRec.bin b/GenoaOpenBoardPkg/S8050BoardPkg/Binaries/BiosDirL20_Typex68_0_9_0_ApcbRec.bin
new file mode 100644
index 0000000000000000000000000000000000000000..74bd92d0b992c3b3bee87b074f4b783d5b2d5389
GIT binary patch
literal 1184
zcmZ<^aCT~7Fko1~!oaY^l!2j>0TsA9I~g%B2rvjSFfb;7rT+hSKvEKc#3q&L<Q(AW
r>+0*yA}+wd2-K_qbOVcc9D@Lm1_BNShX4P;tWjb#1V%$(M1}wWbP){!

literal 0
HcmV?d00001

diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.dxe.inc.fdf b/GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.dxe.inc.fdf
new file mode 100644
index 0000000..becdfb1
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.dxe.inc.fdf
@@ -0,0 +1,13 @@
+#;*****************************************************************************
+#; Copyright (C) 2020-2024 Advanced Micro Devices, Inc. All rights reserved.
+#;
+#;*****************************************************************************
+#
+## @file
+# CRB specific - External AGESA DXE build.
+#
+##
+  #
+  # AMD AGESA DXE Includes - External
+  #
+  #!include AgesaModulePkg/AgesaSp5RsModulePkg.dxe.inc.fdf
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.inc.dsc b/GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.inc.dsc
new file mode 100644
index 0000000..dfc6e4a
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.inc.dsc
@@ -0,0 +1,13 @@
+#;*****************************************************************************
+#; Copyright (C) 2020-2024 Advanced Micro Devices, Inc. All rights reserved.
+#;
+#;******************************************************************************
+#
+## @file
+# CRB specific - AGCL-R build.
+#
+##
+  #
+  # AMD AGCL-R Includes
+  #
+  !include AgesaModulePkg/AgesaSp5GenoaModulePkg.inc.dsc
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.pei.inc.fdf b/GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.pei.inc.fdf
new file mode 100644
index 0000000..f022c10
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Include/AgesaInc/AgesaExt.pei.inc.fdf
@@ -0,0 +1,13 @@
+#;*****************************************************************************
+#; Copyright (C) 2020-2024 Advanced Micro Devices, Inc. All rights reserved.
+#;
+#;*****************************************************************************
+#
+## @file
+# CRB specific - External AGESA PEI build.
+#
+##
+  #
+  # AMD AGESA PEI Includes - External
+  #
+  !include AgesaModulePkg/AgesaSp5GenoaModulePkg.pei.inc.fdf
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Include/Dsc/Smbios.dsc b/GenoaOpenBoardPkg/S8050BoardPkg/Include/Dsc/Smbios.dsc
new file mode 100644
index 0000000..cf2610e
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Include/Dsc/Smbios.dsc
@@ -0,0 +1,95 @@
+#;*****************************************************************************
+#; Copyright (C) 2021-2024 Advanced Micro Devices, Inc. All rights reserved.
+#;
+#;******************************************************************************
+#
+## @file
+# Smbios Platform description.
+#
+##
+
+[PcdsFixedAtBuild]
+  #****************************************************************************
+  # COMMON SMBIOS
+  #****************************************************************************
+  #
+  # IPMI Interface Type
+  #
+  # 0 - Unknown
+  # 1 - KCS
+  # 2 - SMIC
+  # 3 - BT
+  # 4 - SSIF
+  gAmdCommonPkgTokenSpaceGuid.PcdIpmiInterfaceType|1
+
+  # SMBIOS Type 4 Processor Information
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdSmbiosSerialNumberSocket0|"Default String"
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdSmbiosAssetTagSocket0|"Default String"
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdSmbiosPartNumberSocket0|"Default String"
+
+[PcdsDynamicDefault]
+  #****************************************************************************
+  # BASIC SMBIOS
+  #****************************************************************************
+  #
+  # SMBIOS Type 0 BIOS Information Strings
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0StringBiosReleaseDate|"$(RELEASE_DATE)"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0StringBiosVersion|"$(FIRMWARE_VERSION_STR)"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.SystemBiosMajorRelease|0xFF
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.SystemBiosMinorRelease|0xFF
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.EmbeddedControllerFirmwareMajorRelease|0xFF
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.EmbeddedControllerFirmwareMinorRelease|0xFF
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.ExtendedBiosSize.Size|32
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.ExtendedBiosSize.Unit|0x00
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BiosCharacteristics.PlugAndPlayIsSupported|0
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BiosCharacteristics.EDDSpecificationIsSupported|0
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BiosCharacteristics.Floppy525_12IsSupported|0
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BiosCharacteristics.Floppy35_720IsSupported|0
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BiosCharacteristics.Floppy35_288IsSupported|0
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BiosCharacteristics.PrintScreenIsSupported|0
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BiosCharacteristics.Keyboard8042IsSupported|0
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BiosCharacteristics.SerialIsSupported|0
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BiosCharacteristics.PrinterIsSupported|0
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BiosCharacteristics.CgaMonoIsSupported|0
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BIOSCharacteristicsExtensionBytes[0]|0x01
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0BiosInformation.BIOSCharacteristicsExtensionBytes[1]|0x0C
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType0StringVendor|"AMD Corporation"
+
+  # SMBIOS Type 1 System Information Strings
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType1StringFamily|$(PROCESSOR_NAME)
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType1StringProductName|$(BOARD_NAME)
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType1SystemInformation.Uuid|{GUID("069F7A75-1155-455F-81E9-2D778481D7EF")}
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType1StringManufacturer|"AMD Corporation"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType1StringSerialNumber|"Default String"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType1StringVersion|"Default String"
+
+  # SMBIOS Type 2 Baseboard Information Strings
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType2StringManufacturer|"AMD Corporation"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType2StringVersion|"Default String"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType2StringAssetTag|"Default String"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType2StringLocationInChassis|"Default String"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType2StringSerialNumber|"Default String"
+
+  # SMBIOS Type 3 System Enclosure Information Strings
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType3StringManufacturer|"AMD Corporation"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType3StringVersion|"Default String"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType3StringAssetTag|"Default String"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType3StringSKUNumber|"Default String"
+  gSmbiosFeaturePkgTokenSpaceGuid.PcdSmbiosType3StringSerialNumber|"Default String"
+
+  # SMBIOS Type 11 OEM Strings
+  gAmdCommonPkgTokenSpaceGuid.PcdType11OemStringsCount|1
+  gAmdCommonPkgTokenSpaceGuid.PcdType11OemStrings|{"Default String"}
+
+  # SMBIOS Type 12 System Configuration Options
+  gAmdCommonPkgTokenSpaceGuid.PcdType12SystemCfgOptionsCount|1
+  gAmdCommonPkgTokenSpaceGuid.PcdType12SystemCfgOptions|{"Default String"}
+
+[Components.X64]
+  MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+  SystemInformation/SmbiosFeaturePkg/SmbiosBasicDxe/SmbiosBasicDxe.inf
+  AmdCommonPkg/Smbios/SmbiosCommonDxe/SmbiosCommonDxe.inf {
+    <LibraryClasses>
+      PciSegmentLib|MdePkg/Library/PciSegmentLibSegmentInfo/BasePciSegmentLibSegmentInfo.inf
+      PciSegmentInfoLib|MinPlatformPkg/Pci/Library/PciSegmentInfoLibSimple/PciSegmentInfoLibSimple.inf
+  }
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Include/Fdf/FlashMapInclude.fdf b/GenoaOpenBoardPkg/S8050BoardPkg/Include/Fdf/FlashMapInclude.fdf
new file mode 100644
index 0000000..e62823d
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Include/Fdf/FlashMapInclude.fdf
@@ -0,0 +1,169 @@
+#;*****************************************************************************
+#; Copyright (C) 2021-2024 Advanced Micro Devices, Inc. All rights reserved.
+#;
+#;*****************************************************************************
+
+
+##############################################################################
+#
+# GenoaOnyx reference board - 2 SPI FLash devices accessible by x86 (selected by DIP-switch):
+# 1) 32MB Flash with 10-pin header next to the VGA connector.
+# 2) 64MB Flash with 10-pin header at 90-degrees from VGA connector, and also accessible by the BMC.
+#
+##############################################################################
+
+##############################################################################
+#
+# BIOS image layout
+#
+##############################################################################
+# +===============================+
+# |Flash Device (FD)              |
+# |BaseAddress = 0xFF000000       |
+# |  ONLY 0xFF000000-0xFFFFFFFF   |
+# |    Visible in MMIO < 4GB      |
+# |Size        = 0x02000000 (32MB)|
+# +===============================+
+    DEFINE ROM2_FLASH_BASE        = 0xFF000000
+    DEFINE ROM2_FLASH_SIZE        = 0x01000000
+    DEFINE ROM3_FLASH_BASE        = 0xFD00000000
+    DEFINE ROM3_FLASH_SIZE        = 0x02000000
+    DEFINE SPI_BLOCK_SIZE         = 0x1000
+    DEFINE SPI_NUM_BLOCKS         = 0x2000
+    DEFINE ROM3_FLASH_ENABLE      = TRUE
+# +===============================+
+# Section                           FD Offset   SPI Addr.   RAM Addr
+# +===============================+ 0x00000000  0xFF000000
+# |Unused             Size=0x20000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x0001FFFF  0xFF01FFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00020000  0xFF020000
+# |Embedded FW Sig    Size=0x1000 |
+    DEFINE FV_FW_SIG_OFFSET       = 0x00020000
+    DEFINE FV_FW_SIG_SIZE         = 0x00001000
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00020FFF  0xFF020FFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00021000  0xFF021000
+# |Unused             Size=0x16000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00036FFF  0xFF036FFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00037000  0xFF037000
+# |UEFI NVRAM         Size=0x20000|
+    DEFINE NVRAM_AREA_VAR_OFFSET  = 0x00037000
+    DEFINE NVRAM_AREA_VAR_SIZE    = 0x0000E000
+    DEFINE NVRAM_AREA_SIZE        = 0x00020000
+
+    DEFINE FTW_WORKING_OFFSET     = $(NVRAM_AREA_VAR_OFFSET) + $(NVRAM_AREA_VAR_SIZE)
+    DEFINE FTW_WORKING_SIZE       = 0x00002000
+
+    DEFINE FTW_SPARE_OFFSET       = $(FTW_WORKING_OFFSET) + $(FTW_WORKING_SIZE)
+    DEFINE FTW_SPARE_SIZE         = $(NVRAM_AREA_SIZE) - $(NVRAM_AREA_VAR_SIZE) - $(FTW_WORKING_SIZE)
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00056FFF  0xFF056FFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00057000  0xFF057000
+# |Unused             Size=0x30000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00086FFF  0xFF086FFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00087000  0xFF087000
+# |Unused              Size=0x1000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00087FFF  0xFF087FFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00088000  0xFF088000
+# |Unused             Size=0x90000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00117FFF  0xFF117FFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00118000  0xFF118000
+# |Unused             Size=0x2E000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00145FFF  0xFF145FFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00146000  0xFF146000
+# |PSP Dir1       Size=0x200000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00345FFF  0xFF345FFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00346000  0xFF346000
+# |BIOS Dir1       Size=0x40000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00385FFF  0xFF385FFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00386000  0xFF386000
+# |Unused              Size=0x1000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00386FFF  0xFF386FFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00387000  0xFF387000
+# |PSP Dir2       Size=0x234000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x005BAFFF  0xFF5BAFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x005BB000  0xFF5BB000
+# |BIOS Dir2      Size=0x40000 |
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x005FAFFF  0xFF5FAFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x005FB000  0xFF5FB000
+# |FV.FvAdvanced      Size=0x90000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x0068AFFF  0xFF68AFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x0068B000  0xFF68B000
+# |FV.FvAdvancedSecurity   0x40000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x006CAFFF  0xFF6CAFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x006CB000  0xFF6CB000
+# |FV. FvOsBoot      Size=0x100000| 0x006CB000  0xFF6CB000
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x007CAFFF  0xFF7CAFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x007CB000  0xFF7CB000
+# |FV.FvUefiBoot     Size=0x300000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00ACAFFF  0xFFACAFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00ACB000  0xFFCAB000
+# |FV.FvSecurity     Size=0x010000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00ADAFFF  0xFFADAFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00ADB000  0xFFADB000
+# |FV.FvPostMemory   Size=0x040000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00B1AFFF  0xFFB1AFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00B1B000  0xFFB1B000
+# |FV.FvAdvancedPreMemory 0x1E5000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00CFFFFF  0xFFCFFFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x00D00000  0xFFD00000  0x76D00000
+# |FV.FvPreMemory    Size=0x300000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x00FFFFFF  0xFFFFFFFF  0x76FFFFFF
+    DEFINE BOOT_FV_BASE           = 0x76D00000
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x01000000
+# |Unused          Size=0x00100000|
+# |^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^| 0x010FFFFF
+# |vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv| 0x01100000
+# |Unused          Size=0x00F00000|
+# +===============================+ 0x01FFFFFF
+
+# SET gMinPlatformPkgTokenSpaceGuid.PcdFlashNvStorageOffset           = 0x00000000
+# SET gMinPlatformPkgTokenSpaceGuid.PcdFlashNvStorageSize             = 0x00040000
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashNvStorageVariableOffset   = $(NVRAM_AREA_VAR_OFFSET)
+SET gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize    = $(NVRAM_AREA_VAR_SIZE)
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingOffset = $(FTW_WORKING_OFFSET)
+SET gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingSize  = $(FTW_WORKING_SIZE)
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareOffset   = $(FTW_SPARE_OFFSET)
+SET gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareSize    = $(FTW_SPARE_SIZE)
+
+# FV offset and size assignment
+# FvSecurity
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvSecurityOffset          = 0x00ACB000
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvSecuritySize            = 0x00010000
+# FvPostMemory
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPostMemoryOffset        = (gMinPlatformPkgTokenSpaceGuid.PcdFlashFvSecurityOffset + gMinPlatformPkgTokenSpaceGuid.PcdFlashFvSecuritySize)
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPostMemorySize          = 0x00040000
+# FvAdvancedPreMemory
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedPreMemoryOffset = (gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPostMemoryOffset + gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPostMemorySize)
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedPreMemorySize   = 0x001E5000
+# FvPreMemory
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPreMemoryOffset         = (gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedPreMemoryOffset + gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedPreMemorySize)
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPreMemorySize           = 0x00300000
+
+# FvAdvanced
+!if $(ROM3_FLASH_ENABLE) == TRUE
+  # if ROM3 is enabled then continue the offset update
+  SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedOffset          = (gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPreMemoryOffset + gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPreMemorySize)
+!else
+  SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedOffset          = 0x005FB000
+!endif
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedSize            = 0x00090000
+# FvAdvancedSecurity
+SET gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecurityOffset = (gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedOffset + gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedSize)
+SET gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecuritySize   = 0x00040000
+# FvOsBoot
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvOsBootOffset            = (gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecurityOffset + gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecuritySize)
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvOsBootSize              = 0x00100000
+# FvUefiBoot
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvUefiBootOffset          = (gMinPlatformPkgTokenSpaceGuid.PcdFlashFvOsBootOffset + gMinPlatformPkgTokenSpaceGuid.PcdFlashFvOsBootSize)
+SET gMinPlatformPkgTokenSpaceGuid.PcdFlashFvUefiBootSize            = 0x00300000
+# AmdCommonPkg
+SET gAmdCommonPkgTokenSpaceGuid.PcdBootFvBase = $(BOOT_FV_BASE)
+SET gAmdCommonPkgTokenSpaceGuid.PcdSecPeiSize = gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPreMemorySize
+
+!if $(ROM3_FLASH_ENABLE) == TRUE
+  SET gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedBase           = $(ROM3_FLASH_BASE)
+  SET gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecurityBase   = (gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedBase + gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedSize)
+  SET gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvOsBootBase             = (gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecurityBase + gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecuritySize)
+  SET gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvUefiBootBase           = (gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvOsBootBase + gMinPlatformPkgTokenSpaceGuid.PcdFlashFvOsBootSize)
+!endif
+
+
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Include/Fdf/Smbios.fdf b/GenoaOpenBoardPkg/S8050BoardPkg/Include/Fdf/Smbios.fdf
new file mode 100644
index 0000000..3e1cfb7
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Include/Fdf/Smbios.fdf
@@ -0,0 +1,8 @@
+#;*****************************************************************************
+#; Copyright (C) 2021-2024 Advanced Micro Devices, Inc. All rights reserved.
+#;
+#;*****************************************************************************
+
+  INF MdeModulePkg/Universal/SmbiosDxe/SmbiosDxe.inf
+  INF SystemInformation/SmbiosFeaturePkg/SmbiosBasicDxe/SmbiosBasicDxe.inf
+  INF AmdCommonPkg/Smbios/SmbiosCommonDxe/SmbiosCommonDxe.inf
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosMiscLib.inf b/GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosMiscLib.inf
new file mode 100644
index 0000000..acab463
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosMiscLib.inf
@@ -0,0 +1,31 @@
+#;*****************************************************************************
+#; Copyright (C) 2021-2024 Advanced Micro Devices, Inc. All rights reserved.
+#;
+#;******************************************************************************
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = SmbiosMiscLib
+  FILE_GUID                      = 9f2700de-25a7-45b8-8d59-9bc43d05a1ec
+  MODULE_TYPE                    = DXE_DRIVER
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = SmbiosMiscLib
+
+[Sources]
+  SmbiosType8PortConnectorInfo.c
+  SmbiosType41OnboardDevExtInfo.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  AmdCommonPkg/AmdCommonPkg.dec
+
+[LibraryClasses]
+  BaseLib
+  DebugLib
+
+[Protocols]
+
+[Pcd]
+
+[Depex]
+  TRUE
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosType41OnboardDevExtInfo.c b/GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosType41OnboardDevExtInfo.c
new file mode 100644
index 0000000..4931400
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosType41OnboardDevExtInfo.c
@@ -0,0 +1,80 @@
+/*****************************************************************************
+ *
+ * Copyright (C) 2020-2024 Advanced Micro Devices, Inc. All rights reserved.
+ *
+ *****************************************************************************/
+
+#include <Library/SmbiosMiscLib.h>
+
+SMBIOS_ONBOARD_DEV_EXT_INFO_RECORD gOnboardDevExtInfo[] = {
+  {
+    0x01,                              // Reference Designation
+    OnBoardDeviceExtendedTypeEthernet, // 0x03, Device Type
+    1,                                 // Device Enabled
+    1,                                 // Device Instance
+    0x14E4,                            // LOM ethernet controller vendor id
+    0x165F,                            // LOM ethernet controller device id
+    "Onboard Ethernet"                 // Designation String
+  }
+};
+
+/**
+  Calculate and output total number of onboard devices present on board.
+
+  @param[out] NumberOfDevices    Pointer to output variable.
+
+  @retval EFI_SUCCESS            Function successfully executed.
+  @retval EFI_INVALID_PARAMETER  If NumberOfDevices == NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+GetNumberOfOnboardDevices (
+  OUT UINT8   *NumberOfDevices
+  )
+{
+  if (NumberOfDevices == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //Calculate total number of onboard devices
+  *NumberOfDevices = sizeof (gOnboardDevExtInfo) / sizeof (SMBIOS_ONBOARD_DEV_EXT_INFO_RECORD);
+
+  return EFI_SUCCESS;
+}
+
+
+/**
+  Output the Type41 Smbios related information for indexed onboard device.
+
+  @param[in]  DevIdx              Device identifier number.
+  @param[out] DevExtInfoRecord    Pointer to output type41 port connector record.
+
+  @retval EFI_SUCCESS             Function successfully executed.
+  @retval EFI_INVALID_PARAMETER   If DevExtInfoRecord == NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+GetType41OnboardDevExtInfo (
+  IN  UINT8                              DevIdx,
+  OUT SMBIOS_ONBOARD_DEV_EXT_INFO_RECORD *DevExtInfoRecord
+  )
+{
+  UINT8 NumberOfDevices;
+
+  if (DevExtInfoRecord == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //Calculate total number of onboard devices
+  NumberOfDevices = sizeof (gOnboardDevExtInfo) / sizeof (SMBIOS_ONBOARD_DEV_EXT_INFO_RECORD);
+
+  if (DevIdx >= NumberOfDevices) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *DevExtInfoRecord = gOnboardDevExtInfo[DevIdx];
+
+  return EFI_SUCCESS;
+}
\ No newline at end of file
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosType8PortConnectorInfo.c b/GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosType8PortConnectorInfo.c
new file mode 100644
index 0000000..d1e58f0
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Library/SmbiosMiscLib/SmbiosType8PortConnectorInfo.c
@@ -0,0 +1,206 @@
+/******************************************************************************
+ * Copyright (C) 2021-2024 Advanced Micro Devices, Inc. All rights reserved.
+ *
+ *******************************************************************************
+ **/
+
+#include <Library/SmbiosMiscLib.h>
+
+SMBIOS_PORT_CONNECTOR_RECORD gPortConnectorRecord[] = {
+  {
+    { {0},
+      0x01, //InternalReferenceDesignator.
+      PortConnectorTypeNone, //0x00, InternalConnectorTypr.
+      0x02, //ExternalReferenceDesignator.
+      PortConnectorTypeUsb,  //0x12, ExternalConnectorType.
+      PortTypeUsb //0x10, PortType.
+    },
+    {
+      "J11",
+      "USB3-R"
+    }
+  },
+  {
+    { {0},
+      0x01, //InternalReferenceDesignator.
+      PortConnectorTypeNone, //0x00, InternalConnectorTypr.
+      0x02, //ExternalReferenceDesignator.
+      PortConnectorTypeUsb,  //0x12, ExternalConnectorType.
+      PortTypeUsb //0x10, PortType.
+    },
+    {
+      "J20",
+      "USB3-R"
+    }
+  },
+  {
+    { {0},
+      0x01, //InternalReferenceDesignator.
+      PortConnectorTypeNone, //0x00, InternalConnectorTypr.
+      0x02, //ExternalReferenceDesignator.
+      PortConnectorTypeUsb,  //0x12, ExternalConnectorType.
+      PortTypeUsb //0x10, PortType.
+    },
+    {
+      "J1F",
+      "USB3-F"
+    }
+  },
+  {
+    { {0},
+      0x01, //InternalReferenceDesignator.
+      PortConnectorTypeNone, //0x00, InternalConnectorTypr.
+      0x02, //ExternalReferenceDesignator.
+      PortConnectorTypeUsb,  //0x12, ExternalConnectorType.
+      PortTypeUsb //0x10, PortType.
+    },
+    {
+      "J2F",
+      "USB3-F"
+    }
+  },
+  {
+    { {0},
+      0x01, //InternalReferenceDesignator.
+      PortConnectorTypeNone, //0x00, InternalConnectorTypr.
+      0x02, //ExternalReferenceDesignator.
+      PortConnectorTypeDB15Female, //0x07, ExternalConnectorType.
+      PortTypeVideoPort //0x1C, PortType.
+    },
+    {
+      "J2",
+      "VGA-R"
+    }
+  },
+  {
+    { {0},
+      0x01, //InternalReferenceDesignator.
+      PortConnectorTypeNone, //0x00, InternalConnectorTypr.
+      0x02, //ExternalReferenceDesignator.
+      PortConnectorTypeDB15Female, //0x07, ExternalConnectorType.
+      PortTypeVideoPort //0x1C, PortType.
+    },
+    {
+      "J3-F",
+      "VGA-F"
+    }
+  },
+  {
+    { {0},
+      0x01, //InternalReferenceDesignator.
+      PortConnectorTypeNone, //0x00, InternalConnectorTypr.
+      0x02, //ExternalReferenceDesignator.
+      PortConnectorTypeDB9Female, //0x09, ExternalConnectorType.
+      PortTypeSerial16550ACompatible //0x09, PortType.
+    },
+    {
+      "J1",
+      "Serial Port Header"
+    }
+  },
+  {
+    { {0},
+      0x01, //InternalReferenceDesignator.
+      PortConnectorTypeNone, //0x00, InternalConnectorTypr.
+      0x02, //ExternalReferenceDesignator.
+      PortConnectorTypeRJ45, //0x0B, ExternalConnectorType.
+      PortTypeNetworkPort //0x1F, PortType.
+    },
+    {
+      "J15",
+      "MGMT RJ45 Port"
+    }
+  },
+  {
+    { {0},
+      0x01, //InternalReferenceDesignator.
+      PortConnectorTypeOther , //0xFF, InternalConnectorTypr.
+      0x00, //ExternalReferenceDesignator.
+      PortConnectorTypeNone, //ExternalConnectorType.
+      PortTypeOther //0xFF, PortType.
+    },
+    {
+      "J75 M2_0",
+      ""
+    }
+  },
+  {
+    { {0},
+      0x01, //InternalReferenceDesignator.
+      PortConnectorTypeOther , //0xFF, InternalConnectorTypr.
+      0x00, //ExternalReferenceDesignator.
+      PortConnectorTypeNone, //ExternalConnectorType.
+      PortTypeOther //0xFF, PortType.
+    },
+    {
+      "J77 M2_1",
+      ""
+    }
+  }
+};
+
+/**
+  This function outputs total number of port connectors present on board.
+
+  @param[out] NumPortConnector   Pointer to output variable.
+
+  @retval EFI_SUCCESS            Function successfully executed.
+  @retval EFI_INVALID_PARAMETER  If NumPortConnector == NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+GetNumberOfPortConnectors (
+  OUT UINT8  *NumPortConnector
+  )
+{
+  UINT8                     NumberOfPortConnector;
+
+  if (NumPortConnector == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //Calculate total number of port connectors.
+  NumberOfPortConnector =
+          sizeof (gPortConnectorRecord)/sizeof (SMBIOS_PORT_CONNECTOR_RECORD);
+
+  *NumPortConnector = NumberOfPortConnector;
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Output the Type8 Smbios related information for indexed port connector.
+
+  @param[in]  PortConnectorIdNum  Port connector identifier number.
+  @param[out] PortConnRecord      Pointer to output type8 port connector record.
+
+  @retval EFI_SUCCESS             Function successfully executed.
+  @retval EFI_INVALID_PARAMETER   If PortConnRecord == NULL.
+
+**/
+EFI_STATUS
+EFIAPI
+GetType8PortConnectorInfo (
+  IN  UINT8                         PortConnectorIdNum,
+  OUT SMBIOS_PORT_CONNECTOR_RECORD  *PortConnRecord
+  )
+{
+  UINT8                     NumberOfPortConnector;
+
+  if (PortConnRecord == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  //Calculate total number of port connectors.
+  NumberOfPortConnector =
+          sizeof (gPortConnectorRecord)/sizeof (SMBIOS_PORT_CONNECTOR_RECORD);
+
+  if (PortConnectorIdNum >= NumberOfPortConnector) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  *PortConnRecord =  gPortConnectorRecord[PortConnectorIdNum];
+
+  return EFI_SUCCESS;
+}
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Override/edk2/MdeModulePkg/Universal/DisplayEngineDxe/InputHandler.c b/GenoaOpenBoardPkg/S8050BoardPkg/Override/edk2/MdeModulePkg/Universal/DisplayEngineDxe/InputHandler.c
new file mode 100644
index 0000000..c938a28
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Override/edk2/MdeModulePkg/Universal/DisplayEngineDxe/InputHandler.c
@@ -0,0 +1,1733 @@
+/** @file
+Implementation for handling user input from the User Interfaces.
+
+Copyright (c) 2004 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "FormDisplay.h"
+
+/**
+  Get maximum and minimum info from this opcode.
+
+  @param  OpCode            Pointer to the current input opcode.
+  @param  Minimum           The minimum size info for this opcode.
+  @param  Maximum           The maximum size info for this opcode.
+
+**/
+VOID
+GetFieldFromOp (
+  IN   EFI_IFR_OP_HEADER  *OpCode,
+  OUT  UINTN              *Minimum,
+  OUT  UINTN              *Maximum
+  )
+{
+  EFI_IFR_STRING    *StringOp;
+  EFI_IFR_PASSWORD  *PasswordOp;
+
+  if (OpCode->OpCode == EFI_IFR_STRING_OP) {
+    StringOp = (EFI_IFR_STRING *)OpCode;
+    *Minimum = StringOp->MinSize;
+    *Maximum = StringOp->MaxSize;
+  } else if (OpCode->OpCode == EFI_IFR_PASSWORD_OP) {
+    PasswordOp = (EFI_IFR_PASSWORD *)OpCode;
+    *Minimum   = PasswordOp->MinSize;
+    *Maximum   = PasswordOp->MaxSize;
+  } else {
+    *Minimum = 0;
+    *Maximum = 0;
+  }
+}
+
+/**
+  Get string or password input from user.
+
+  @param  MenuOption        Pointer to the current input menu.
+  @param  Prompt            The prompt string shown on popup window.
+  @param  StringPtr         Old user input and destination for use input string.
+
+  @retval EFI_SUCCESS       If string input is read successfully
+  @retval EFI_DEVICE_ERROR  If operation fails
+
+**/
+EFI_STATUS
+ReadString (
+  IN     UI_MENU_OPTION  *MenuOption,
+  IN     CHAR16          *Prompt,
+  IN OUT CHAR16          *StringPtr
+  )
+{
+  EFI_STATUS                     Status;
+  EFI_INPUT_KEY                  Key;
+  CHAR16                         NullCharacter;
+  UINTN                          ScreenSize;
+  CHAR16                         Space[2];
+  CHAR16                         KeyPad[2];
+  CHAR16                         *TempString;
+  CHAR16                         *BufferedString;
+  UINTN                          Index;
+  UINTN                          Index2;
+  UINTN                          Count;
+  UINTN                          Start;
+  UINTN                          Top;
+  UINTN                          DimensionsWidth;
+  UINTN                          DimensionsHeight;
+  UINTN                          CurrentCursor;
+  BOOLEAN                        CursorVisible;
+  UINTN                          Minimum;
+  UINTN                          Maximum;
+  FORM_DISPLAY_ENGINE_STATEMENT  *Question;
+  BOOLEAN                        IsPassword;
+  UINTN                          MaxLen;
+
+  DimensionsWidth  = gStatementDimensions.RightColumn - gStatementDimensions.LeftColumn;
+  DimensionsHeight = gStatementDimensions.BottomRow - gStatementDimensions.TopRow;
+
+  NullCharacter = CHAR_NULL;
+  ScreenSize    = GetStringWidth (Prompt) / sizeof (CHAR16);
+  Space[0]      = L' ';
+  Space[1]      = CHAR_NULL;
+
+  Question = MenuOption->ThisTag;
+  GetFieldFromOp (Question->OpCode, &Minimum, &Maximum);
+
+  if (Question->OpCode->OpCode == EFI_IFR_PASSWORD_OP) {
+    IsPassword = TRUE;
+  } else {
+    IsPassword = FALSE;
+  }
+
+  MaxLen     = Maximum + 1;
+  TempString = AllocateZeroPool (MaxLen * sizeof (CHAR16));
+  ASSERT (TempString);
+
+  if (ScreenSize < (Maximum + 1)) {
+    ScreenSize = Maximum + 1;
+  }
+
+  if ((ScreenSize + 2) > DimensionsWidth) {
+    ScreenSize = DimensionsWidth - 2;
+  }
+
+  BufferedString = AllocateZeroPool (ScreenSize * 2);
+  ASSERT (BufferedString);
+
+  Start = (DimensionsWidth - ScreenSize - 2) / 2 + gStatementDimensions.LeftColumn + 1;
+  Top   = ((DimensionsHeight - 6) / 2) + gStatementDimensions.TopRow - 1;
+
+  //
+  // Display prompt for string
+  //
+  // CreateDialog (NULL, "", Prompt, Space, "", NULL);
+  CreateMultiStringPopUp (ScreenSize, 4, &NullCharacter, Prompt, Space, &NullCharacter);
+  gST->ConOut->SetAttribute (gST->ConOut, EFI_TEXT_ATTR (EFI_BLACK, EFI_LIGHTGRAY));
+
+  CursorVisible = gST->ConOut->Mode->CursorVisible;
+  gST->ConOut->EnableCursor (gST->ConOut, TRUE);
+
+  CurrentCursor = GetStringWidth (StringPtr) / 2 - 1;
+  if (CurrentCursor != 0) {
+    //
+    // Show the string which has beed saved before.
+    //
+    SetUnicodeMem (BufferedString, ScreenSize - 1, L' ');
+    PrintStringAt (Start + 1, Top + 3, BufferedString);
+
+    if ((GetStringWidth (StringPtr) / 2) > (DimensionsWidth - 2)) {
+      Index = (GetStringWidth (StringPtr) / 2) - DimensionsWidth + 2;
+    } else {
+      Index = 0;
+    }
+
+    if (IsPassword) {
+      gST->ConOut->SetCursorPosition (gST->ConOut, Start + 1, Top + 3);
+    }
+
+    for (Count = 0; Index + 1 < GetStringWidth (StringPtr) / 2; Index++, Count++) {
+      BufferedString[Count] = StringPtr[Index];
+
+      if (IsPassword) {
+        PrintCharAt ((UINTN)-1, (UINTN)-1, L'*');
+      }
+    }
+
+    if (!IsPassword) {
+      PrintStringAt (Start + 1, Top + 3, BufferedString);
+    }
+
+    gST->ConOut->SetAttribute (gST->ConOut, EFI_TEXT_ATTR (EFI_LIGHTGRAY, EFI_BLACK));
+    gST->ConOut->SetCursorPosition (gST->ConOut, Start + GetStringWidth (StringPtr) / 2, Top + 3);
+  }
+
+  do {
+    Status = WaitForKeyStroke (&Key);
+    ASSERT_EFI_ERROR (Status);
+
+    gST->ConOut->SetAttribute (gST->ConOut, EFI_TEXT_ATTR (EFI_BLACK, EFI_LIGHTGRAY));
+    switch (Key.UnicodeChar) {
+      case CHAR_NULL:
+        switch (Key.ScanCode) {
+          case SCAN_LEFT:
+            if (CurrentCursor > 0) {
+              CurrentCursor--;
+            }
+
+            break;
+
+          case SCAN_RIGHT:
+            if (CurrentCursor < (GetStringWidth (StringPtr) / 2 - 1)) {
+              CurrentCursor++;
+            }
+
+            break;
+
+          case SCAN_ESC:
+            FreePool (TempString);
+            FreePool (BufferedString);
+            gST->ConOut->SetAttribute (gST->ConOut, EFI_TEXT_ATTR (EFI_LIGHTGRAY, EFI_BLACK));
+            gST->ConOut->EnableCursor (gST->ConOut, CursorVisible);
+            return EFI_DEVICE_ERROR;
+
+          case SCAN_DELETE:
+            for (Index = CurrentCursor; StringPtr[Index] != CHAR_NULL; Index++) {
+              StringPtr[Index] = StringPtr[Index + 1];
+              PrintCharAt (Start + Index + 1, Top + 3, IsPassword && StringPtr[Index] != CHAR_NULL ? L'*' : StringPtr[Index]);
+            }
+
+            break;
+
+          default:
+            break;
+        }
+
+        break;
+
+      case CHAR_CARRIAGE_RETURN:
+        if (GetStringWidth (StringPtr) >= ((Minimum + 1) * sizeof (CHAR16))) {
+          FreePool (TempString);
+          FreePool (BufferedString);
+          gST->ConOut->SetAttribute (gST->ConOut, EFI_TEXT_ATTR (EFI_LIGHTGRAY, EFI_BLACK));
+          gST->ConOut->EnableCursor (gST->ConOut, CursorVisible);
+          return EFI_SUCCESS;
+        } else {
+          //
+          // Simply create a popup to tell the user that they had typed in too few characters.
+          // To save code space, we can then treat this as an error and return back to the menu.
+          //
+          do {
+            CreateDialog (&Key, &NullCharacter, gMiniString, gPressEnter, &NullCharacter, NULL);
+          } while (Key.UnicodeChar != CHAR_CARRIAGE_RETURN);
+
+          FreePool (TempString);
+          FreePool (BufferedString);
+          gST->ConOut->SetAttribute (gST->ConOut, EFI_TEXT_ATTR (EFI_LIGHTGRAY, EFI_BLACK));
+          gST->ConOut->EnableCursor (gST->ConOut, CursorVisible);
+          return EFI_DEVICE_ERROR;
+        }
+
+      case CHAR_BACKSPACE:
+        if ((StringPtr[0] != CHAR_NULL) && (CurrentCursor != 0)) {
+          for (Index = 0; Index < CurrentCursor - 1; Index++) {
+            TempString[Index] = StringPtr[Index];
+          }
+
+          Count = GetStringWidth (StringPtr) / 2 - 1;
+          if (Count >= CurrentCursor) {
+            for (Index = CurrentCursor - 1, Index2 = CurrentCursor; Index2 < Count; Index++, Index2++) {
+              TempString[Index] = StringPtr[Index2];
+            }
+
+            TempString[Index] = CHAR_NULL;
+          }
+
+          //
+          // Effectively truncate string by 1 character
+          //
+          StrCpyS (StringPtr, MaxLen, TempString);
+          CurrentCursor--;
+        }
+
+      default:
+        //
+        // If it is the beginning of the string, don't worry about checking maximum limits
+        //
+        if ((StringPtr[0] == CHAR_NULL) && (Key.UnicodeChar != CHAR_BACKSPACE)) {
+          StrnCpyS (StringPtr, MaxLen, &Key.UnicodeChar, 1);
+          CurrentCursor++;
+        } else if ((GetStringWidth (StringPtr) < ((Maximum + 1) * sizeof (CHAR16))) && (Key.UnicodeChar != CHAR_BACKSPACE)) {
+          KeyPad[0] = Key.UnicodeChar;
+          KeyPad[1] = CHAR_NULL;
+          Count     = GetStringWidth (StringPtr) / 2 - 1;
+          if (CurrentCursor < Count) {
+            for (Index = 0; Index < CurrentCursor; Index++) {
+              TempString[Index] = StringPtr[Index];
+            }
+
+            TempString[Index] = CHAR_NULL;
+            StrCatS (TempString, MaxLen, KeyPad);
+            StrCatS (TempString, MaxLen, StringPtr + CurrentCursor);
+            StrCpyS (StringPtr, MaxLen, TempString);
+          } else {
+            StrCatS (StringPtr, MaxLen, KeyPad);
+          }
+
+          CurrentCursor++;
+        }
+
+        //
+        // If the width of the input string is now larger than the screen, we nee to
+        // adjust the index to start printing portions of the string
+        //
+        SetUnicodeMem (BufferedString, ScreenSize - 1, L' ');
+        PrintStringAt (Start + 1, Top + 3, BufferedString);
+
+        if ((GetStringWidth (StringPtr) / 2) > (DimensionsWidth - 2)) {
+          Index = (GetStringWidth (StringPtr) / 2) - DimensionsWidth + 2;
+        } else {
+          Index = 0;
+        }
+
+        if (IsPassword) {
+          gST->ConOut->SetCursorPosition (gST->ConOut, Start + 1, Top + 3);
+        }
+
+        for (Count = 0; Index + 1 < GetStringWidth (StringPtr) / 2; Index++, Count++) {
+          BufferedString[Count] = StringPtr[Index];
+
+          if (IsPassword) {
+            PrintCharAt ((UINTN)-1, (UINTN)-1, L'*');
+          }
+        }
+
+        if (!IsPassword) {
+          PrintStringAt (Start + 1, Top + 3, BufferedString);
+        }
+
+        break;
+    }
+
+    gST->ConOut->SetAttribute (gST->ConOut, EFI_TEXT_ATTR (EFI_LIGHTGRAY, EFI_BLACK));
+    gST->ConOut->SetCursorPosition (gST->ConOut, Start + CurrentCursor + 1, Top + 3);
+  } while (TRUE);
+}
+
+/**
+  Adjust the value to the correct one. Rules follow the sample:
+  like:  Year change:  2012.02.29 -> 2013.02.29 -> 2013.02.01
+         Month change: 2013.03.29 -> 2013.02.29 -> 2013.02.28
+
+  @param  QuestionValue     Pointer to current question.
+  @param  Sequence          The sequence of the field in the question.
+**/
+VOID
+AdjustQuestionValue (
+  IN  EFI_HII_VALUE  *QuestionValue,
+  IN  UINT8          Sequence
+  )
+{
+  UINT8   Month;
+  UINT16  Year;
+  UINT8   Maximum;
+  UINT8   Minimum;
+
+  Month   = QuestionValue->Value.date.Month;
+  Year    = QuestionValue->Value.date.Year;
+  Minimum = 1;
+
+  switch (Month) {
+    case 2:
+      if (((Year % 4) == 0) && (((Year % 100) != 0) || ((Year % 400) == 0))) {
+        Maximum = 29;
+      } else {
+        Maximum = 28;
+      }
+
+      break;
+    case 4:
+    case 6:
+    case 9:
+    case 11:
+      Maximum = 30;
+      break;
+    default:
+      Maximum = 31;
+      break;
+  }
+
+  //
+  // Change the month area.
+  //
+  if (Sequence == 0) {
+    if (QuestionValue->Value.date.Day > Maximum) {
+      QuestionValue->Value.date.Day = Maximum;
+    }
+  }
+
+  //
+  // Change the Year area.
+  //
+  if (Sequence == 2) {
+    if (QuestionValue->Value.date.Day > Maximum) {
+      QuestionValue->Value.date.Day = Minimum;
+    }
+  }
+}
+
+/**
+  Get field info from numeric opcode.
+
+  @param  OpCode            Pointer to the current input opcode.
+  @param  IntInput          Whether question shows with EFI_IFR_DISPLAY_INT_DEC type.
+  @param  QuestionValue     Input question value, with EFI_HII_VALUE type.
+  @param  Value             Return question value, always return UINT64 type.
+  @param  Minimum           The minimum size info for this opcode.
+  @param  Maximum           The maximum size info for this opcode.
+  @param  Step              The step size info for this opcode.
+  @param  StorageWidth      The storage width info for this opcode.
+
+**/
+VOID
+GetValueFromNum (
+  IN  EFI_IFR_OP_HEADER  *OpCode,
+  IN  BOOLEAN            IntInput,
+  IN  EFI_HII_VALUE      *QuestionValue,
+  OUT UINT64             *Value,
+  OUT UINT64             *Minimum,
+  OUT UINT64             *Maximum,
+  OUT UINT64             *Step,
+  OUT UINT16             *StorageWidth
+  )
+{
+  EFI_IFR_NUMERIC  *NumericOp;
+
+  NumericOp = (EFI_IFR_NUMERIC *)OpCode;
+
+  switch (NumericOp->Flags & EFI_IFR_NUMERIC_SIZE) {
+    case EFI_IFR_NUMERIC_SIZE_1:
+      if (IntInput) {
+        *Minimum = (INT64)(INT8)NumericOp->data.u8.MinValue;
+        *Maximum = (INT64)(INT8)NumericOp->data.u8.MaxValue;
+        *Value   = (INT64)(INT8)QuestionValue->Value.u8;
+      } else {
+        *Minimum = NumericOp->data.u8.MinValue;
+        *Maximum = NumericOp->data.u8.MaxValue;
+        *Value   = QuestionValue->Value.u8;
+      }
+
+      *Step         = NumericOp->data.u8.Step;
+      *StorageWidth = (UINT16)sizeof (UINT8);
+      break;
+
+    case EFI_IFR_NUMERIC_SIZE_2:
+      if (IntInput) {
+        *Minimum = (INT64)(INT16)NumericOp->data.u16.MinValue;
+        *Maximum = (INT64)(INT16)NumericOp->data.u16.MaxValue;
+        *Value   = (INT64)(INT16)QuestionValue->Value.u16;
+      } else {
+        *Minimum = NumericOp->data.u16.MinValue;
+        *Maximum = NumericOp->data.u16.MaxValue;
+        *Value   = QuestionValue->Value.u16;
+      }
+
+      *Step         = NumericOp->data.u16.Step;
+      *StorageWidth = (UINT16)sizeof (UINT16);
+      break;
+
+    case EFI_IFR_NUMERIC_SIZE_4:
+      if (IntInput) {
+        *Minimum = (INT64)(INT32)NumericOp->data.u32.MinValue;
+        *Maximum = (INT64)(INT32)NumericOp->data.u32.MaxValue;
+        *Value   = (INT64)(INT32)QuestionValue->Value.u32;
+      } else {
+        *Minimum = NumericOp->data.u32.MinValue;
+        *Maximum = NumericOp->data.u32.MaxValue;
+        *Value   = QuestionValue->Value.u32;
+      }
+
+      *Step         = NumericOp->data.u32.Step;
+      *StorageWidth = (UINT16)sizeof (UINT32);
+      break;
+
+    case EFI_IFR_NUMERIC_SIZE_8:
+      if (IntInput) {
+        *Minimum = (INT64)NumericOp->data.u64.MinValue;
+        *Maximum = (INT64)NumericOp->data.u64.MaxValue;
+        *Value   = (INT64)QuestionValue->Value.u64;
+      } else {
+        *Minimum = NumericOp->data.u64.MinValue;
+        *Maximum = NumericOp->data.u64.MaxValue;
+        *Value   = QuestionValue->Value.u64;
+      }
+
+      *Step         = NumericOp->data.u64.Step;
+      *StorageWidth = (UINT16)sizeof (UINT64);
+      break;
+
+    default:
+      break;
+  }
+
+  if (*Maximum == 0) {
+    *Maximum = (UINT64)-1;
+  }
+}
+
+/**
+  This routine reads a numeric value from the user input.
+
+  @param  MenuOption        Pointer to the current input menu.
+
+  @retval EFI_SUCCESS       If numerical input is read successfully
+  @retval EFI_DEVICE_ERROR  If operation fails
+
+**/
+EFI_STATUS
+GetNumericInput (
+  IN  UI_MENU_OPTION  *MenuOption
+  )
+{
+  UINTN                          Column;
+  UINTN                          Row;
+  CHAR16                         InputText[MAX_NUMERIC_INPUT_WIDTH];
+  CHAR16                         FormattedNumber[MAX_NUMERIC_INPUT_WIDTH - 1];
+  UINT64                         PreviousNumber[MAX_NUMERIC_INPUT_WIDTH - 3];
+  UINTN                          Count;
+  UINTN                          Loop;
+  BOOLEAN                        ManualInput;
+  BOOLEAN                        HexInput;
+  BOOLEAN                        IntInput;
+  BOOLEAN                        Negative;
+  BOOLEAN                        ValidateFail;
+  BOOLEAN                        DateOrTime;
+  UINTN                          InputWidth;
+  UINT64                         EditValue;
+  UINT64                         Step;
+  UINT64                         Minimum;
+  UINT64                         Maximum;
+  UINTN                          EraseLen;
+  UINT8                          Digital;
+  EFI_INPUT_KEY                  Key;
+  EFI_HII_VALUE                  *QuestionValue;
+  FORM_DISPLAY_ENGINE_STATEMENT  *Question;
+  EFI_IFR_NUMERIC                *NumericOp;
+  UINT16                         StorageWidth;
+
+  Column            = MenuOption->OptCol;
+  Row               = MenuOption->Row;
+  PreviousNumber[0] = 0;
+  Count             = 0;
+  InputWidth        = 0;
+  Digital           = 0;
+  StorageWidth      = 0;
+  Minimum           = 0;
+  Maximum           = 0;
+  NumericOp         = NULL;
+  IntInput          = FALSE;
+  HexInput          = FALSE;
+  Negative          = FALSE;
+  ValidateFail      = FALSE;
+
+  Question      = MenuOption->ThisTag;
+  QuestionValue = &Question->CurrentValue;
+  ZeroMem (InputText, MAX_NUMERIC_INPUT_WIDTH * sizeof (CHAR16));
+
+  //
+  // Only two case, user can enter to this function: Enter and +/- case.
+  // In Enter case, gDirection = 0; in +/- case, gDirection = SCAN_LEFT/SCAN_WRIGHT
+  //
+  ManualInput = (BOOLEAN)(gDirection == 0 ? TRUE : FALSE);
+
+  if ((Question->OpCode->OpCode == EFI_IFR_DATE_OP) || (Question->OpCode->OpCode == EFI_IFR_TIME_OP)) {
+    DateOrTime = TRUE;
+  } else {
+    DateOrTime = FALSE;
+  }
+
+  //
+  // Prepare Value to be edit
+  //
+  EraseLen  = 0;
+  EditValue = 0;
+  if (Question->OpCode->OpCode == EFI_IFR_DATE_OP) {
+    Step    = 1;
+    Minimum = 1;
+
+    switch (MenuOption->Sequence) {
+      case 0:
+        Maximum   = 12;
+        EraseLen  = 4;
+        EditValue = QuestionValue->Value.date.Month;
+        break;
+
+      case 1:
+        switch (QuestionValue->Value.date.Month) {
+          case 2:
+            if (((QuestionValue->Value.date.Year % 4) == 0) &&
+                (((QuestionValue->Value.date.Year % 100) != 0) ||
+                 ((QuestionValue->Value.date.Year % 400) == 0)))
+            {
+              Maximum = 29;
+            } else {
+              Maximum = 28;
+            }
+
+            break;
+          case 4:
+          case 6:
+          case 9:
+          case 11:
+            Maximum = 30;
+            break;
+          default:
+            Maximum = 31;
+            break;
+        }
+
+        EraseLen  = 3;
+        EditValue = QuestionValue->Value.date.Day;
+        break;
+
+      case 2:
+        Maximum   = 0xffff;
+        EraseLen  = 5;
+        EditValue = QuestionValue->Value.date.Year;
+        break;
+
+      default:
+        break;
+    }
+  } else if (Question->OpCode->OpCode == EFI_IFR_TIME_OP) {
+    Step    = 1;
+    Minimum = 0;
+
+    switch (MenuOption->Sequence) {
+      case 0:
+        Maximum   = 23;
+        EraseLen  = 4;
+        EditValue = QuestionValue->Value.time.Hour;
+        break;
+
+      case 1:
+        Maximum   = 59;
+        EraseLen  = 3;
+        EditValue = QuestionValue->Value.time.Minute;
+        break;
+
+      case 2:
+        Maximum   = 59;
+        EraseLen  = 3;
+        EditValue = QuestionValue->Value.time.Second;
+        break;
+
+      default:
+        break;
+    }
+  } else {
+    ASSERT (Question->OpCode->OpCode == EFI_IFR_NUMERIC_OP);
+    NumericOp = (EFI_IFR_NUMERIC *)Question->OpCode;
+    GetValueFromNum (Question->OpCode, (NumericOp->Flags & EFI_IFR_DISPLAY) == 0, QuestionValue, &EditValue, &Minimum, &Maximum, &Step, &StorageWidth);
+    EraseLen = gOptionBlockWidth;
+  }
+
+  if ((Question->OpCode->OpCode == EFI_IFR_NUMERIC_OP) && (NumericOp != NULL)) {
+    if ((NumericOp->Flags & EFI_IFR_DISPLAY) == EFI_IFR_DISPLAY_UINT_HEX) {
+      HexInput = TRUE;
+    } else if ((NumericOp->Flags & EFI_IFR_DISPLAY) == 0) {
+      //
+      // Display with EFI_IFR_DISPLAY_INT_DEC type. Support negative number.
+      //
+      IntInput = TRUE;
+    }
+  }
+
+  //
+  // Enter from "Enter" input, clear the old word showing.
+  //
+  if (ManualInput) {
+    if (Question->OpCode->OpCode == EFI_IFR_NUMERIC_OP) {
+      if (HexInput) {
+        InputWidth = StorageWidth * 2;
+      } else {
+        switch (StorageWidth) {
+          case 1:
+            InputWidth = 3;
+            break;
+
+          case 2:
+            InputWidth = 5;
+            break;
+
+          case 4:
+            InputWidth = 10;
+            break;
+
+          case 8:
+            InputWidth = 20;
+            break;
+
+          default:
+            InputWidth = 0;
+            break;
+        }
+
+        if (IntInput) {
+          //
+          // Support an extra '-' for negative number.
+          //
+          InputWidth += 1;
+        }
+      }
+
+      InputText[0] = LEFT_NUMERIC_DELIMITER;
+      SetUnicodeMem (InputText + 1, InputWidth, L' ');
+      ASSERT (InputWidth + 2 < MAX_NUMERIC_INPUT_WIDTH);
+      InputText[InputWidth + 1] = RIGHT_NUMERIC_DELIMITER;
+      InputText[InputWidth + 2] = L'\0';
+
+      PrintStringAt (Column, Row, InputText);
+      Column++;
+    }
+
+    if (Question->OpCode->OpCode == EFI_IFR_DATE_OP) {
+      if (MenuOption->Sequence == 2) {
+        InputWidth = 4;
+      } else {
+        InputWidth = 2;
+      }
+
+      if (MenuOption->Sequence == 0) {
+        InputText[0] = LEFT_NUMERIC_DELIMITER;
+        SetUnicodeMem (InputText + 1, InputWidth, L' ');
+        InputText[InputWidth + 1] = DATE_SEPARATOR;
+        InputText[InputWidth + 2] = L'\0';
+      } else if (MenuOption->Sequence == 1) {
+        SetUnicodeMem (InputText, InputWidth, L' ');
+        InputText[InputWidth]     = DATE_SEPARATOR;
+        InputText[InputWidth + 1] = L'\0';
+      } else {
+        SetUnicodeMem (InputText, InputWidth, L' ');
+        InputText[InputWidth]     = RIGHT_NUMERIC_DELIMITER;
+        InputText[InputWidth + 1] = L'\0';
+      }
+
+      PrintStringAt (Column, Row, InputText);
+      if (MenuOption->Sequence == 0) {
+        Column++;
+      }
+    }
+
+    if (Question->OpCode->OpCode == EFI_IFR_TIME_OP) {
+      InputWidth = 2;
+
+      if (MenuOption->Sequence == 0) {
+        InputText[0] = LEFT_NUMERIC_DELIMITER;
+        SetUnicodeMem (InputText + 1, InputWidth, L' ');
+        InputText[InputWidth + 1] = TIME_SEPARATOR;
+        InputText[InputWidth + 2] = L'\0';
+      } else if (MenuOption->Sequence == 1) {
+        SetUnicodeMem (InputText, InputWidth, L' ');
+        InputText[InputWidth]     = TIME_SEPARATOR;
+        InputText[InputWidth + 1] = L'\0';
+      } else {
+        SetUnicodeMem (InputText, InputWidth, L' ');
+        InputText[InputWidth]     = RIGHT_NUMERIC_DELIMITER;
+        InputText[InputWidth + 1] = L'\0';
+      }
+
+      PrintStringAt (Column, Row, InputText);
+      if (MenuOption->Sequence == 0) {
+        Column++;
+      }
+    }
+  }
+
+  //
+  // First time we enter this handler, we need to check to see if
+  // we were passed an increment or decrement directive
+  //
+  do {
+    Key.UnicodeChar = CHAR_NULL;
+    if (gDirection != 0) {
+      Key.ScanCode = gDirection;
+      gDirection   = 0;
+      goto TheKey2;
+    }
+
+    WaitForKeyStroke (&Key);
+
+TheKey2:
+    switch (Key.UnicodeChar) {
+      case '+':
+      case '-':
+        if (ManualInput && IntInput) {
+          //
+          // In Manual input mode, check whether input the negative flag.
+          //
+          if (Key.UnicodeChar == '-') {
+            if (Negative) {
+              break;
+            }
+
+            Negative = TRUE;
+            PrintCharAt (Column++, Row, Key.UnicodeChar);
+          }
+        } else {
+          if (Key.UnicodeChar == '+') {
+            Key.ScanCode = SCAN_RIGHT;
+          } else {
+            Key.ScanCode = SCAN_LEFT;
+          }
+
+          Key.UnicodeChar = CHAR_NULL;
+          goto TheKey2;
+        }
+
+        break;
+
+      case CHAR_NULL:
+        switch (Key.ScanCode) {
+          case SCAN_LEFT:
+          case SCAN_RIGHT:
+            if (DateOrTime && !ManualInput) {
+              //
+              // By setting this value, we will return back to the caller.
+              // We need to do this since an auto-refresh will destroy the adjustment
+              // based on what the real-time-clock is showing.  So we always commit
+              // upon changing the value.
+              //
+              gDirection = SCAN_DOWN;
+            }
+
+            if ((Step != 0) && !ManualInput) {
+              if (Key.ScanCode == SCAN_LEFT) {
+                if (IntInput) {
+                  if ((INT64)EditValue >= (INT64)Minimum + (INT64)Step) {
+                    EditValue = EditValue - Step;
+                  } else if ((INT64)EditValue > (INT64)Minimum) {
+                    EditValue = Minimum;
+                  } else {
+                    EditValue = Maximum;
+                  }
+                } else {
+                  if (EditValue >= Minimum + Step) {
+                    EditValue = EditValue - Step;
+                  } else if (EditValue > Minimum) {
+                    EditValue = Minimum;
+                  } else {
+                    EditValue = Maximum;
+                  }
+                }
+              } else if (Key.ScanCode == SCAN_RIGHT) {
+                if (IntInput) {
+                  if ((INT64)EditValue + (INT64)Step <= (INT64)Maximum) {
+                    EditValue = EditValue + Step;
+                  } else if ((INT64)EditValue < (INT64)Maximum) {
+                    EditValue = Maximum;
+                  } else {
+                    EditValue = Minimum;
+                  }
+                } else {
+                  if (EditValue + Step <= Maximum) {
+                    EditValue = EditValue + Step;
+                  } else if (EditValue < Maximum) {
+                    EditValue = Maximum;
+                  } else {
+                    EditValue = Minimum;
+                  }
+                }
+              }
+
+              ZeroMem (FormattedNumber, 21 * sizeof (CHAR16));
+              if (Question->OpCode->OpCode == EFI_IFR_DATE_OP) {
+                if (MenuOption->Sequence == 2) {
+                  //
+                  // Year
+                  //
+                  UnicodeSPrint (FormattedNumber, 21 * sizeof (CHAR16), L"%04d", (UINT16)EditValue);
+                } else {
+                  //
+                  // Month/Day
+                  //
+                  UnicodeSPrint (FormattedNumber, 21 * sizeof (CHAR16), L"%02d", (UINT8)EditValue);
+                }
+
+                if (MenuOption->Sequence == 0) {
+                  ASSERT (EraseLen >= 2);
+                  FormattedNumber[EraseLen - 2] = DATE_SEPARATOR;
+                } else if (MenuOption->Sequence == 1) {
+                  ASSERT (EraseLen >= 1);
+                  FormattedNumber[EraseLen - 1] = DATE_SEPARATOR;
+                }
+              } else if (Question->OpCode->OpCode == EFI_IFR_TIME_OP) {
+                UnicodeSPrint (FormattedNumber, 21 * sizeof (CHAR16), L"%02d", (UINT8)EditValue);
+
+                if (MenuOption->Sequence == 0) {
+                  ASSERT (EraseLen >= 2);
+                  FormattedNumber[EraseLen - 2] = TIME_SEPARATOR;
+                } else if (MenuOption->Sequence == 1) {
+                  ASSERT (EraseLen >= 1);
+                  FormattedNumber[EraseLen - 1] = TIME_SEPARATOR;
+                }
+              } else {
+                QuestionValue->Value.u64 = EditValue;
+                PrintFormattedNumber (Question, FormattedNumber, 21 * sizeof (CHAR16));
+              }
+
+              gST->ConOut->SetAttribute (gST->ConOut, GetFieldTextColor ());
+              for (Loop = 0; Loop < EraseLen; Loop++) {
+                PrintStringAt (MenuOption->OptCol + Loop, MenuOption->Row, L" ");
+              }
+
+              gST->ConOut->SetAttribute (gST->ConOut, GetHighlightTextColor ());
+
+              if (MenuOption->Sequence == 0) {
+                PrintCharAt (MenuOption->OptCol, Row, LEFT_NUMERIC_DELIMITER);
+                Column = MenuOption->OptCol + 1;
+              }
+
+              PrintStringAt (Column, Row, FormattedNumber);
+
+              if (!DateOrTime || (MenuOption->Sequence == 2)) {
+                PrintCharAt ((UINTN)-1, (UINTN)-1, RIGHT_NUMERIC_DELIMITER);
+              }
+            }
+
+            goto EnterCarriageReturn;
+
+          case SCAN_UP:
+          case SCAN_DOWN:
+            goto EnterCarriageReturn;
+
+          case SCAN_ESC:
+            return EFI_DEVICE_ERROR;
+
+          default:
+            break;
+        }
+
+        break;
+
+EnterCarriageReturn:
+
+      case CHAR_CARRIAGE_RETURN:
+        //
+        // Validate input value with Minimum value.
+        //
+        ValidateFail = FALSE;
+        if (IntInput) {
+          //
+          // After user input Enter, need to check whether the input value.
+          // If input a negative value, should compare with maximum value.
+          // else compare with the minimum value.
+          //
+          if (Negative) {
+            ValidateFail = (INT64)EditValue > (INT64)Maximum ? TRUE : FALSE;
+          } else {
+            ValidateFail = (INT64)EditValue < (INT64)Minimum ? TRUE : FALSE;
+          }
+
+          if (ValidateFail) {
+            UpdateStatusBar (INPUT_ERROR, TRUE);
+            break;
+          }
+        } else if (EditValue < Minimum) {
+          UpdateStatusBar (INPUT_ERROR, TRUE);
+          break;
+        }
+
+        UpdateStatusBar (INPUT_ERROR, FALSE);
+        CopyMem (&gUserInput->InputValue, &Question->CurrentValue, sizeof (EFI_HII_VALUE));
+        QuestionValue = &gUserInput->InputValue;
+        //
+        // Store Edit value back to Question
+        //
+        if (Question->OpCode->OpCode == EFI_IFR_DATE_OP) {
+          switch (MenuOption->Sequence) {
+            case 0:
+              QuestionValue->Value.date.Month = (UINT8)EditValue;
+              break;
+
+            case 1:
+              QuestionValue->Value.date.Day = (UINT8)EditValue;
+              break;
+
+            case 2:
+              QuestionValue->Value.date.Year = (UINT16)EditValue;
+              break;
+
+            default:
+              break;
+          }
+        } else if (Question->OpCode->OpCode  == EFI_IFR_TIME_OP) {
+          switch (MenuOption->Sequence) {
+            case 0:
+              QuestionValue->Value.time.Hour = (UINT8)EditValue;
+              break;
+
+            case 1:
+              QuestionValue->Value.time.Minute = (UINT8)EditValue;
+              break;
+
+            case 2:
+              QuestionValue->Value.time.Second = (UINT8)EditValue;
+              break;
+
+            default:
+              break;
+          }
+        } else {
+          //
+          // Numeric
+          //
+          QuestionValue->Value.u64 = EditValue;
+        }
+
+        //
+        // Adjust the value to the correct one.
+        // Sample like: 2012.02.29 -> 2013.02.29 -> 2013.02.01
+        //              2013.03.29 -> 2013.02.29 -> 2013.02.28
+        //
+        if ((Question->OpCode->OpCode  == EFI_IFR_DATE_OP) &&
+            ((MenuOption->Sequence == 0) || (MenuOption->Sequence == 2)))
+        {
+          AdjustQuestionValue (QuestionValue, (UINT8)MenuOption->Sequence);
+        }
+
+        return EFI_SUCCESS;
+
+      case CHAR_BACKSPACE:
+        if (ManualInput) {
+          if (Count == 0) {
+            if (Negative) {
+              Negative = FALSE;
+              Column--;
+              PrintStringAt (Column, Row, L" ");
+            }
+
+            break;
+          }
+
+          //
+          // Remove a character
+          //
+          EditValue = PreviousNumber[Count - 1];
+          UpdateStatusBar (INPUT_ERROR, FALSE);
+          Count--;
+          Column--;
+          PrintStringAt (Column, Row, L" ");
+        }
+
+        break;
+
+      default:
+        if (ManualInput) {
+          if (HexInput) {
+            if ((Key.UnicodeChar >= L'0') && (Key.UnicodeChar <= L'9')) {
+              Digital = (UINT8)(Key.UnicodeChar - L'0');
+            } else if ((Key.UnicodeChar >= L'A') && (Key.UnicodeChar <= L'F')) {
+              Digital = (UINT8)(Key.UnicodeChar - L'A' + 0x0A);
+            } else if ((Key.UnicodeChar >= L'a') && (Key.UnicodeChar <= L'f')) {
+              Digital = (UINT8)(Key.UnicodeChar - L'a' + 0x0A);
+            } else {
+              UpdateStatusBar (INPUT_ERROR, TRUE);
+              break;
+            }
+          } else {
+            if ((Key.UnicodeChar > L'9') || (Key.UnicodeChar < L'0')) {
+              UpdateStatusBar (INPUT_ERROR, TRUE);
+              break;
+            }
+          }
+
+          //
+          // If Count exceed input width, there is no way more is valid
+          //
+          if (Count >= InputWidth) {
+            break;
+          }
+
+          //
+          // Someone typed something valid!
+          //
+          if (Count != 0) {
+            if (HexInput) {
+              EditValue = LShiftU64 (EditValue, 4) + Digital;
+            } else if (IntInput && Negative) {
+              //
+              // Save the negative number.
+              //
+              EditValue = ~(MultU64x32 (~(EditValue - 1), 10) + (Key.UnicodeChar - L'0')) + 1;
+            } else {
+              EditValue = MultU64x32 (EditValue, 10) + (Key.UnicodeChar - L'0');
+            }
+          } else {
+            if (HexInput) {
+              EditValue = Digital;
+            } else if (IntInput && Negative) {
+              //
+              // Save the negative number.
+              //
+              EditValue = ~(Key.UnicodeChar - L'0') + 1;
+            } else {
+              EditValue = Key.UnicodeChar - L'0';
+            }
+          }
+
+          if (IntInput) {
+            ValidateFail = FALSE;
+            //
+            // When user input a new value, should check the current value.
+            // If user input a negative value, should compare it with minimum
+            // value, else compare it with maximum value.
+            //
+            if (Negative) {
+              ValidateFail = (INT64)EditValue < (INT64)Minimum ? TRUE : FALSE;
+            } else {
+              ValidateFail = (INT64)EditValue > (INT64)Maximum ? TRUE : FALSE;
+            }
+
+            if (ValidateFail) {
+              UpdateStatusBar (INPUT_ERROR, TRUE);
+              ASSERT (Count < ARRAY_SIZE (PreviousNumber));
+              EditValue = PreviousNumber[Count];
+              break;
+            }
+          } else {
+            if (EditValue > Maximum) {
+              UpdateStatusBar (INPUT_ERROR, TRUE);
+              ASSERT (Count < ARRAY_SIZE (PreviousNumber));
+              EditValue = PreviousNumber[Count];
+              break;
+            }
+          }
+
+          UpdateStatusBar (INPUT_ERROR, FALSE);
+
+          Count++;
+          ASSERT (Count < (ARRAY_SIZE (PreviousNumber)));
+          PreviousNumber[Count] = EditValue;
+
+          gST->ConOut->SetAttribute (gST->ConOut, GetHighlightTextColor ());
+          PrintCharAt (Column, Row, Key.UnicodeChar);
+          Column++;
+        }
+
+        break;
+    }
+  } while (TRUE);
+}
+
+/**
+  Adjust option order base on the question value.
+
+  @param  Question           Pointer to current question.
+  @param  PopUpMenuLines     The line number of the pop up menu.
+
+  @retval EFI_SUCCESS       If Option input is processed successfully
+  @retval EFI_DEVICE_ERROR  If operation fails
+
+**/
+EFI_STATUS
+AdjustOptionOrder (
+  IN  FORM_DISPLAY_ENGINE_STATEMENT  *Question,
+  OUT UINTN                          *PopUpMenuLines
+  )
+{
+  UINTN                    Index;
+  EFI_IFR_ORDERED_LIST     *OrderList;
+  UINT8                    *ValueArray;
+  UINT8                    ValueType;
+  LIST_ENTRY               *Link;
+  DISPLAY_QUESTION_OPTION  *OneOfOption;
+  EFI_HII_VALUE            *HiiValueArray;
+
+  Link        = GetFirstNode (&Question->OptionListHead);
+  OneOfOption = DISPLAY_QUESTION_OPTION_FROM_LINK (Link);
+  ValueArray  = Question->CurrentValue.Buffer;
+  ValueType   =  OneOfOption->OptionOpCode->Type;
+  OrderList   = (EFI_IFR_ORDERED_LIST *)Question->OpCode;
+
+  for (Index = 0; Index < OrderList->MaxContainers; Index++) {
+    if (GetArrayData (ValueArray, ValueType, Index) == 0) {
+      break;
+    }
+  }
+
+  *PopUpMenuLines = Index;
+
+  //
+  // Prepare HiiValue array
+  //
+  HiiValueArray = AllocateZeroPool (*PopUpMenuLines * sizeof (EFI_HII_VALUE));
+  ASSERT (HiiValueArray != NULL);
+
+  for (Index = 0; Index < *PopUpMenuLines; Index++) {
+    HiiValueArray[Index].Type      = ValueType;
+    HiiValueArray[Index].Value.u64 = GetArrayData (ValueArray, ValueType, Index);
+  }
+
+  for (Index = 0; Index < *PopUpMenuLines; Index++) {
+    OneOfOption = ValueToOption (Question, &HiiValueArray[*PopUpMenuLines - Index - 1]);
+    if (OneOfOption == NULL) {
+      return EFI_NOT_FOUND;
+    }
+
+    RemoveEntryList (&OneOfOption->Link);
+
+    //
+    // Insert to head.
+    //
+    InsertHeadList (&Question->OptionListHead, &OneOfOption->Link);
+  }
+
+  FreePool (HiiValueArray);
+
+  return EFI_SUCCESS;
+}
+
+/**
+  Base on the type to compare the value.
+
+  @param  Value1                The first value need to compare.
+  @param  Value2                The second value need to compare.
+  @param  Type                  The value type for above two values.
+
+  @retval TRUE                  The two value are same.
+  @retval FALSE                 The two value are different.
+
+**/
+BOOLEAN
+IsValuesEqual (
+  IN EFI_IFR_TYPE_VALUE  *Value1,
+  IN EFI_IFR_TYPE_VALUE  *Value2,
+  IN UINT8               Type
+  )
+{
+  switch (Type) {
+    case EFI_IFR_TYPE_BOOLEAN:
+    case EFI_IFR_TYPE_NUM_SIZE_8:
+      return (BOOLEAN)(Value1->u8 == Value2->u8);
+
+    case EFI_IFR_TYPE_NUM_SIZE_16:
+      return (BOOLEAN)(Value1->u16 == Value2->u16);
+
+    case EFI_IFR_TYPE_NUM_SIZE_32:
+      return (BOOLEAN)(Value1->u32 == Value2->u32);
+
+    case EFI_IFR_TYPE_NUM_SIZE_64:
+      return (BOOLEAN)(Value1->u64 == Value2->u64);
+
+    default:
+      ASSERT (FALSE);
+      return FALSE;
+  }
+}
+
+/**
+  Base on the type to set the value.
+
+  @param  Dest                  The dest value.
+  @param  Source                The source value.
+  @param  Type                  The value type for above two values.
+
+**/
+VOID
+SetValuesByType (
+  OUT EFI_IFR_TYPE_VALUE  *Dest,
+  IN  EFI_IFR_TYPE_VALUE  *Source,
+  IN  UINT8               Type
+  )
+{
+  switch (Type) {
+    case EFI_IFR_TYPE_BOOLEAN:
+      Dest->b = Source->b;
+      break;
+
+    case EFI_IFR_TYPE_NUM_SIZE_8:
+      Dest->u8 = Source->u8;
+      break;
+
+    case EFI_IFR_TYPE_NUM_SIZE_16:
+      Dest->u16 = Source->u16;
+      break;
+
+    case EFI_IFR_TYPE_NUM_SIZE_32:
+      Dest->u32 = Source->u32;
+      break;
+
+    case EFI_IFR_TYPE_NUM_SIZE_64:
+      Dest->u64 = Source->u64;
+      break;
+
+    default:
+      ASSERT (FALSE);
+      break;
+  }
+}
+
+/**
+  Get selection for OneOf and OrderedList (Left/Right will be ignored).
+
+  @param  MenuOption        Pointer to the current input menu.
+
+  @retval EFI_SUCCESS       If Option input is processed successfully
+  @retval EFI_DEVICE_ERROR  If operation fails
+
+**/
+EFI_STATUS
+GetSelectionInputPopUp (
+  IN  UI_MENU_OPTION  *MenuOption
+  )
+{
+  EFI_INPUT_KEY                  Key;
+  UINTN                          Index;
+  CHAR16                         *StringPtr;
+  CHAR16                         *TempStringPtr;
+  UINTN                          Index2;
+  UINTN                          TopOptionIndex;
+  UINTN                          HighlightOptionIndex;
+  UINTN                          Start;
+  UINTN                          End;
+  UINTN                          Top;
+  UINTN                          Bottom;
+  UINTN                          PopUpMenuLines;
+  UINTN                          MenuLinesInView;
+  UINTN                          PopUpWidth;
+  CHAR16                         Character;
+  INT32                          SavedAttribute;
+  BOOLEAN                        ShowDownArrow;
+  BOOLEAN                        ShowUpArrow;
+  UINTN                          DimensionsWidth;
+  LIST_ENTRY                     *Link;
+  BOOLEAN                        OrderedList;
+  UINT8                          *ValueArray;
+  UINT8                          *ReturnValue;
+  UINT8                          ValueType;
+  EFI_HII_VALUE                  HiiValue;
+  DISPLAY_QUESTION_OPTION        *OneOfOption;
+  DISPLAY_QUESTION_OPTION        *CurrentOption;
+  FORM_DISPLAY_ENGINE_STATEMENT  *Question;
+  INTN                           Result;
+  EFI_IFR_ORDERED_LIST           *OrderList;
+
+  DimensionsWidth = gStatementDimensions.RightColumn - gStatementDimensions.LeftColumn;
+
+  ValueArray    = NULL;
+  ValueType     = 0;
+  CurrentOption = NULL;
+  ShowDownArrow = FALSE;
+  ShowUpArrow   = FALSE;
+
+  ZeroMem (&HiiValue, sizeof (EFI_HII_VALUE));
+
+  Question = MenuOption->ThisTag;
+  if (Question->OpCode->OpCode == EFI_IFR_ORDERED_LIST_OP) {
+    Link        = GetFirstNode (&Question->OptionListHead);
+    OneOfOption = DISPLAY_QUESTION_OPTION_FROM_LINK (Link);
+    ValueArray  = Question->CurrentValue.Buffer;
+    ValueType   =  OneOfOption->OptionOpCode->Type;
+    OrderedList = TRUE;
+    OrderList   = (EFI_IFR_ORDERED_LIST *)Question->OpCode;
+  } else {
+    OrderedList = FALSE;
+    OrderList   = NULL;
+  }
+
+  //
+  // Calculate Option count
+  //
+  PopUpMenuLines = 0;
+  if (OrderedList) {
+    AdjustOptionOrder (Question, &PopUpMenuLines);
+  } else {
+    Link = GetFirstNode (&Question->OptionListHead);
+    while (!IsNull (&Question->OptionListHead, Link)) {
+      OneOfOption = DISPLAY_QUESTION_OPTION_FROM_LINK (Link);
+      PopUpMenuLines++;
+      Link = GetNextNode (&Question->OptionListHead, Link);
+    }
+  }
+
+  //
+  // Get the number of one of options present and its size
+  //
+  PopUpWidth           = 0;
+  HighlightOptionIndex = 0;
+  Link                 = GetFirstNode (&Question->OptionListHead);
+  for (Index = 0; Index < PopUpMenuLines; Index++) {
+    OneOfOption = DISPLAY_QUESTION_OPTION_FROM_LINK (Link);
+
+    StringPtr = GetToken (OneOfOption->OptionOpCode->Option, gFormData->HiiHandle);
+    if (StrLen (StringPtr) > PopUpWidth) {
+      PopUpWidth = StrLen (StringPtr);
+    }
+
+    FreePool (StringPtr);
+    HiiValue.Type = OneOfOption->OptionOpCode->Type;
+    SetValuesByType (&HiiValue.Value, &OneOfOption->OptionOpCode->Value, HiiValue.Type);
+    if (!OrderedList && (CompareHiiValue (&Question->CurrentValue, &HiiValue, &Result, NULL) == EFI_SUCCESS) && (Result == 0)) {
+      //
+      // Find current selected Option for OneOf
+      //
+      HighlightOptionIndex = Index;
+    }
+
+    Link = GetNextNode (&Question->OptionListHead, Link);
+  }
+
+  //
+  // Perform popup menu initialization.
+  //
+  PopUpWidth = PopUpWidth + POPUP_PAD_SPACE_COUNT;
+
+  SavedAttribute = gST->ConOut->Mode->Attribute;
+  gST->ConOut->SetAttribute (gST->ConOut, GetPopupColor ());
+
+  if ((PopUpWidth + POPUP_FRAME_WIDTH) > DimensionsWidth) {
+    PopUpWidth = DimensionsWidth - POPUP_FRAME_WIDTH;
+  }
+
+  Start  = (DimensionsWidth - PopUpWidth - POPUP_FRAME_WIDTH) / 2 + gStatementDimensions.LeftColumn;
+  End    = Start + PopUpWidth + POPUP_FRAME_WIDTH;
+  Top    = gStatementDimensions.TopRow;
+  Bottom = gStatementDimensions.BottomRow - 1;
+
+  MenuLinesInView = Bottom - Top - 1;
+  if (MenuLinesInView >= PopUpMenuLines) {
+    Top    = Top + (MenuLinesInView - PopUpMenuLines) / 2;
+    Bottom = Top + PopUpMenuLines + 1;
+  } else {
+    ShowDownArrow = TRUE;
+  }
+
+  if (HighlightOptionIndex > (MenuLinesInView - 1)) {
+    TopOptionIndex = HighlightOptionIndex - MenuLinesInView + 1;
+  } else {
+    TopOptionIndex = 0;
+  }
+
+  do {
+    //
+    // Clear that portion of the screen
+    //
+    ClearLines (Start, End, Top, Bottom, GetPopupColor ());
+
+    //
+    // Draw "One of" pop-up menu
+    //
+    Character = BOXDRAW_DOWN_RIGHT;
+    PrintCharAt (Start, Top, Character);
+    for (Index = Start; Index + 2 < End; Index++) {
+      if ((ShowUpArrow) && ((Index + 1) == (Start + End) / 2)) {
+        Character = GEOMETRICSHAPE_UP_TRIANGLE;
+      } else {
+        Character = BOXDRAW_HORIZONTAL;
+      }
+
+      PrintCharAt ((UINTN)-1, (UINTN)-1, Character);
+    }
+
+    Character = BOXDRAW_DOWN_LEFT;
+    PrintCharAt ((UINTN)-1, (UINTN)-1, Character);
+    Character = BOXDRAW_VERTICAL;
+    for (Index = Top + 1; Index < Bottom; Index++) {
+      PrintCharAt (Start, Index, Character);
+      PrintCharAt (End - 1, Index, Character);
+    }
+
+    //
+    // Move to top Option
+    //
+    Link = GetFirstNode (&Question->OptionListHead);
+    for (Index = 0; Index < TopOptionIndex; Index++) {
+      Link = GetNextNode (&Question->OptionListHead, Link);
+    }
+
+    //
+    // Display the One of options
+    //
+    Index2 = Top + 1;
+    for (Index = TopOptionIndex; (Index < PopUpMenuLines) && (Index2 < Bottom); Index++) {
+      OneOfOption = DISPLAY_QUESTION_OPTION_FROM_LINK (Link);
+      Link        = GetNextNode (&Question->OptionListHead, Link);
+
+      StringPtr = GetToken (OneOfOption->OptionOpCode->Option, gFormData->HiiHandle);
+      ASSERT (StringPtr != NULL);
+      //
+      // If the string occupies multiple lines, truncate it to fit in one line,
+      // and append a "..." for indication.
+      //
+      if (StrLen (StringPtr) > (PopUpWidth - 1)) {
+        TempStringPtr = AllocateZeroPool (sizeof (CHAR16) * (PopUpWidth - 1));
+        ASSERT (TempStringPtr != NULL);
+        CopyMem (TempStringPtr, StringPtr, (sizeof (CHAR16) * (PopUpWidth - 5)));
+        FreePool (StringPtr);
+        StringPtr = TempStringPtr;
+        StrCatS (StringPtr, PopUpWidth - 1, L"...");
+      }
+
+      if (Index == HighlightOptionIndex) {
+        //
+        // Highlight the selected one
+        //
+        CurrentOption = OneOfOption;
+
+        gST->ConOut->SetAttribute (gST->ConOut, GetPickListColor ());
+        PrintStringAt (Start + 2, Index2, StringPtr);
+        gST->ConOut->SetAttribute (gST->ConOut, GetPopupColor ());
+      } else {
+        gST->ConOut->SetAttribute (gST->ConOut, GetPopupColor ());
+        PrintStringAt (Start + 2, Index2, StringPtr);
+      }
+
+      Index2++;
+      FreePool (StringPtr);
+    }
+
+    Character = BOXDRAW_UP_RIGHT;
+    PrintCharAt (Start, Bottom, Character);
+    for (Index = Start; Index + 2 < End; Index++) {
+      if ((ShowDownArrow) && ((Index + 1) == (Start + End) / 2)) {
+        Character = GEOMETRICSHAPE_DOWN_TRIANGLE;
+      } else {
+        Character = BOXDRAW_HORIZONTAL;
+      }
+
+      PrintCharAt ((UINTN)-1, (UINTN)-1, Character);
+    }
+
+    Character = BOXDRAW_UP_LEFT;
+    PrintCharAt ((UINTN)-1, (UINTN)-1, Character);
+
+    //
+    // Get User selection
+    //
+    Key.UnicodeChar = CHAR_NULL;
+    if ((gDirection == SCAN_UP) || (gDirection == SCAN_DOWN)) {
+      Key.ScanCode = gDirection;
+      gDirection   = 0;
+      goto TheKey;
+    }
+
+    WaitForKeyStroke (&Key);
+
+TheKey:
+    switch (Key.UnicodeChar) {
+      case '+':
+        if (OrderedList) {
+          if ((TopOptionIndex > 0) && (TopOptionIndex == HighlightOptionIndex)) {
+            //
+            // Highlight reaches the top of the popup window, scroll one menu item.
+            //
+            TopOptionIndex--;
+            ShowDownArrow = TRUE;
+          }
+
+          if (TopOptionIndex == 0) {
+            ShowUpArrow = FALSE;
+          }
+
+          if (HighlightOptionIndex > 0) {
+            HighlightOptionIndex--;
+
+            ASSERT (CurrentOption != NULL);
+            SwapListEntries (CurrentOption->Link.BackLink, &CurrentOption->Link);
+          }
+        }
+
+        break;
+
+      case '-':
+        //
+        // If an ordered list op-code, we will allow for a popup of +/- keys
+        // to create an ordered list of items
+        //
+        if (OrderedList) {
+          if (((TopOptionIndex + MenuLinesInView) < PopUpMenuLines) &&
+              (HighlightOptionIndex == (TopOptionIndex + MenuLinesInView - 1)))
+          {
+            //
+            // Highlight reaches the bottom of the popup window, scroll one menu item.
+            //
+            TopOptionIndex++;
+            ShowUpArrow = TRUE;
+          }
+
+          if ((TopOptionIndex + MenuLinesInView) == PopUpMenuLines) {
+            ShowDownArrow = FALSE;
+          }
+
+          if (HighlightOptionIndex < (PopUpMenuLines - 1)) {
+            HighlightOptionIndex++;
+
+            ASSERT (CurrentOption != NULL);
+            SwapListEntries (&CurrentOption->Link, CurrentOption->Link.ForwardLink);
+          }
+        }
+
+        break;
+//-->^V_OVERRIDE_START: Enable ^, V to select OneOf and OrderedList.
+      case '^':
+        if ((TopOptionIndex > 0) && (TopOptionIndex == HighlightOptionIndex)) {
+          //
+          // Highlight reaches the top of the popup window, scroll one menu item.
+          //
+          TopOptionIndex--;
+          ShowDownArrow = TRUE;
+        }
+
+        if (TopOptionIndex == 0) {
+          ShowUpArrow = FALSE;
+        }
+
+        if (HighlightOptionIndex > 0) {
+          HighlightOptionIndex--;
+        }
+
+        break;
+
+      case 'V':
+      case 'v':
+        if (((TopOptionIndex + MenuLinesInView) < PopUpMenuLines) &&
+            (HighlightOptionIndex == (TopOptionIndex + MenuLinesInView - 1)))
+        {
+          //
+          // Highlight reaches the bottom of the popup window, scroll one menu item.
+          //
+          TopOptionIndex++;
+          ShowUpArrow = TRUE;
+        }
+
+        if ((TopOptionIndex + MenuLinesInView) == PopUpMenuLines) {
+          ShowDownArrow = FALSE;
+        }
+
+        if (HighlightOptionIndex < (PopUpMenuLines - 1)) {
+          HighlightOptionIndex++;
+        }
+
+        break;
+ //<--^V_OVERRIDE_END
+      case CHAR_NULL:
+        switch (Key.ScanCode) {
+          case SCAN_UP:
+          case SCAN_DOWN:
+            if (Key.ScanCode == SCAN_UP) {
+              if ((TopOptionIndex > 0) && (TopOptionIndex == HighlightOptionIndex)) {
+                //
+                // Highlight reaches the top of the popup window, scroll one menu item.
+                //
+                TopOptionIndex--;
+                ShowDownArrow = TRUE;
+              }
+
+              if (TopOptionIndex == 0) {
+                ShowUpArrow = FALSE;
+              }
+
+              if (HighlightOptionIndex > 0) {
+                HighlightOptionIndex--;
+              }
+            } else {
+              if (((TopOptionIndex + MenuLinesInView) < PopUpMenuLines) &&
+                  (HighlightOptionIndex == (TopOptionIndex + MenuLinesInView - 1)))
+              {
+                //
+                // Highlight reaches the bottom of the popup window, scroll one menu item.
+                //
+                TopOptionIndex++;
+                ShowUpArrow = TRUE;
+              }
+
+              if ((TopOptionIndex + MenuLinesInView) == PopUpMenuLines) {
+                ShowDownArrow = FALSE;
+              }
+
+              if (HighlightOptionIndex < (PopUpMenuLines - 1)) {
+                HighlightOptionIndex++;
+              }
+            }
+
+            break;
+
+          case SCAN_ESC:
+            gST->ConOut->SetAttribute (gST->ConOut, SavedAttribute);
+
+            //
+            // Restore link list order for orderedlist
+            //
+            if (OrderedList) {
+              HiiValue.Type      = ValueType;
+              HiiValue.Value.u64 = 0;
+              for (Index = 0; Index < OrderList->MaxContainers; Index++) {
+                HiiValue.Value.u64 = GetArrayData (ValueArray, ValueType, Index);
+                if (HiiValue.Value.u64 == 0) {
+                  break;
+                }
+
+                OneOfOption = ValueToOption (Question, &HiiValue);
+                if (OneOfOption == NULL) {
+                  return EFI_NOT_FOUND;
+                }
+
+                RemoveEntryList (&OneOfOption->Link);
+                InsertTailList (&Question->OptionListHead, &OneOfOption->Link);
+              }
+            }
+
+            return EFI_DEVICE_ERROR;
+
+          default:
+            break;
+        }
+
+        break;
+
+      case CHAR_CARRIAGE_RETURN:
+        //
+        // return the current selection
+        //
+        if (OrderedList) {
+          ReturnValue = AllocateZeroPool (Question->CurrentValue.BufferLen);
+          ASSERT (ReturnValue != NULL);
+          Index = 0;
+          Link  = GetFirstNode (&Question->OptionListHead);
+          while (!IsNull (&Question->OptionListHead, Link)) {
+            OneOfOption = DISPLAY_QUESTION_OPTION_FROM_LINK (Link);
+            Link        = GetNextNode (&Question->OptionListHead, Link);
+
+            SetArrayData (ReturnValue, ValueType, Index, OneOfOption->OptionOpCode->Value.u64);
+
+            Index++;
+            if (Index > OrderList->MaxContainers) {
+              break;
+            }
+          }
+
+          if (CompareMem (ReturnValue, ValueArray, Question->CurrentValue.BufferLen) == 0) {
+            FreePool (ReturnValue);
+            return EFI_DEVICE_ERROR;
+          } else {
+            gUserInput->InputValue.Buffer    = ReturnValue;
+            gUserInput->InputValue.BufferLen = Question->CurrentValue.BufferLen;
+          }
+        } else {
+          ASSERT (CurrentOption != NULL);
+          gUserInput->InputValue.Type = CurrentOption->OptionOpCode->Type;
+          if (IsValuesEqual (&Question->CurrentValue.Value, &CurrentOption->OptionOpCode->Value, gUserInput->InputValue.Type)) {
+            return EFI_DEVICE_ERROR;
+          } else {
+            SetValuesByType (&gUserInput->InputValue.Value, &CurrentOption->OptionOpCode->Value, gUserInput->InputValue.Type);
+          }
+        }
+
+        gST->ConOut->SetAttribute (gST->ConOut, SavedAttribute);
+
+        return EFI_SUCCESS;
+
+      default:
+        break;
+    }
+  } while (TRUE);
+}
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Project.dsc b/GenoaOpenBoardPkg/S8050BoardPkg/Project.dsc
new file mode 100644
index 0000000..71b3c5c
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Project.dsc
@@ -0,0 +1,1370 @@
+#;*****************************************************************************
+#; Copyright (C) 2024 MiTAC Computing, Inc. All rights reserved.
+#;
+#;******************************************************************************
+#;*****************************************************************************
+#; Copyright (C) 2019-2024 Advanced Micro Devices, Inc. All rights reserved.
+#;
+#;******************************************************************************
+
+# *****************************************************************************
+# Defines passed into build
+# RELEASE_DATE
+# FIRMWARE_REVISION_NUM
+# FIRMWARE_VERSION_STR
+# SIL_PLATFORM_NAME
+# AMD_PROCESSOR
+# *****************************************************************************
+
+[Defines]
+  PROCESSOR_NAME                 = Genoa
+  PROCESSOR_PATH                 = $(PROCESSOR_NAME)OpenBoardPkg
+  BOARD_NAME                     = S8050
+  PLATFORM_NAME                  = $(BOARD_NAME)BoardPkg
+  PLATFORM_GUID                  = 0b5350f0-7076-11eb-9439-0242ac130002
+  PLATFORM_VERSION               = 0.01
+  DSC_SPECIFICATION              = 0x00010005
+  OUTPUT_DIRECTORY               = Build/$(PLATFORM_NAME)_$(PROCESSOR_NAME)
+  OUTPUT_DIRECTORY               = $(OUTPUT_DIRECTORY)_EXTERNAL
+  SUPPORTED_ARCHITECTURES        = IA32|X64
+  BUILD_TARGETS                  = DEBUG|RELEASE|NOOPT
+  SKUID_IDENTIFIER               = DEFAULT
+  FLASH_DEFINITION               = $(PLATFORM_NAME)/Project.fdf
+
+  DEFINE  PEI_ARCH               = IA32
+  DEFINE  DXE_ARCH               = X64
+  PREBUILD = "python Platform/PlatformTools/support/prepostbuild_launcher.py prebuild"
+  POSTBUILD = "python Platform/PlatformTools/support/prepostbuild_launcher.py postbuild"
+
+  #
+  # Platform On/Off features are defined here
+  #
+  DEFINE SOURCE_DEBUG_ENABLE   = FALSE
+  DEFINE DEBUG_DISPATCH_ENABLE = TRUE
+  DEFINE DISABLE_SMT           = FALSE
+
+  #
+  # Unit Test Enable/Disable features are defined here
+  #
+  DEFINE UNIT_TEST_AMD_AML_ENABLE   = FALSE
+
+  DEFINE AMD_RESET_DXE_DRIVER_SUPPORT_DISABLED  = TRUE
+
+  # Non-runtime UEFI output
+  DEFINE LOGGING_ENABLE        = TRUE
+  # SMM and Dxe runtime debug message control
+  DEFINE RUNTIME_LOGGING_ENABLE = FALSE
+
+  DEFINE USE_1GB_PAGE_TABLES   = TRUE
+  # EDK2 components are starting to use PLATFORMX64_ENABLE in their include
+  # DSC/FDF files
+  DEFINE PLATFORMX64_ENABLE    = TRUE
+
+  DEFINE AMD_CSM_SUPPORT_DISABLED = TRUE
+
+  # Disable IPV6 and HttpBoot
+  DEFINE NETWORK_IP6_ENABLE       = FALSE
+  DEFINE NETWORK_HTTP_ENABLE      = FALSE
+  DEFINE NETWORK_HTTP_BOOT_ENABLE = FALSE
+
+  DEFINE SATA_SUPPORT             = TRUE
+  DEFINE USB_SUPPORT              = TRUE
+
+  # SERIAL_PORT Options:
+  #   NONE
+  #   FCH_MMIO    UART0, MMIO
+  #   FCH_IO      UART0, 0x3F8
+  #   BMC_SOL     UART1, MMIO
+  #   BMC_SOL_IO  UART1, 0x2F8
+  #   BMC_ESPI    eSPI0, 0x3F8
+  #     Note - BMC_ESPI requires the following settings:
+  #            1. APCB_TOKEN_UID_FCH_CONSOLE_OUT_ENABLE_VALUE = 1
+  #            2. APCB_TOKEN_UID_FCH_CONSOLE_OUT_SERIAL_PORT_VALUE = 0
+  #            3. BMC configured to use eSPI virtual UART 0x3F8
+  DEFINE SERIAL_PORT            = "BMC_SOL_IO"
+
+  #
+  # Set Serial Port Base Address
+  #
+  !if $(SERIAL_PORT) == "BMC_SOL"
+    DEFINE SERIAL_REGISTER_BASE = 0xFEDCA000
+  !elseif $(SERIAL_PORT) == "BMC_SOL_IO"
+    DEFINE SERIAL_REGISTER_BASE = 0x2F8
+  !elseif $(SERIAL_PORT) == "FCH_MMIO"
+    DEFINE SERIAL_REGISTER_BASE = 0xFEDC9000
+  !elseif $(SERIAL_PORT) == "FCH_IO"
+    DEFINE SERIAL_REGISTER_BASE = 0x3F8
+  !elseif $(SERIAL_PORT) == "BMC_ESPI"
+    DEFINE SERIAL_REGISTER_BASE = 0x3F8
+  !else
+    DEFINE SERIAL_REGISTER_BASE = 0xFEDC9000
+  !endif
+
+  #
+  # AMD AGCL Include Path
+  #
+  DEFINE AGESA_INC_DSC = $(PLATFORM_NAME)/Include/AgesaInc/AgesaExt.inc.dsc
+
+#-----------------------------------------------------------
+#  End of [Defines] section
+#-----------------------------------------------------------
+
+  #
+  # AMD AGCL Includes - After [Defines] section.
+  #
+  !include $(AGESA_INC_DSC)
+  !include $(PLATFORM_NAME)/Include/Dsc/Smbios.dsc
+
+  # OPENSIL
+  !include AmdOpenSilPkg/opensil-uefi-interface/AmdOpenSilPkg.dsc
+
+[Packages]
+  MinPlatformPkg/MinPlatformPkg.dec
+  Network/NetworkFeaturePkg/NetworkFeaturePkg.dec
+
+[PcdsFixedAtBuild]
+  ######################################
+  # Key Boot Stage
+  ######################################
+  #
+  # Please select the Boot Stage here.
+  # Stage 1 - enable debug (system deadloop after debug init)
+  # Stage 2 - mem init (system deadloop after mem init)
+  # Stage 3 - boot to shell only
+  # Stage 4 - boot to OS
+  # Stage 5 - boot to OS with security boot enabled
+  # Stage 6 - boot with advanced features enabled
+  #
+  gMinPlatformPkgTokenSpaceGuid.PcdBootStage|3
+
+[PcdsFeatureFlag]
+  ######################################
+  # Platform Configuration
+  ######################################
+  gMinPlatformPkgTokenSpaceGuid.PcdStopAfterDebugInit|FALSE
+  gMinPlatformPkgTokenSpaceGuid.PcdStopAfterMemInit|FALSE
+  gMinPlatformPkgTokenSpaceGuid.PcdSmiHandlerProfileEnable|FALSE
+  gMinPlatformPkgTokenSpaceGuid.PcdUefiSecureBootEnable|FALSE
+  gMinPlatformPkgTokenSpaceGuid.PcdPerformanceEnable|FALSE
+  gMinPlatformPkgTokenSpaceGuid.PcdTpm2Enable|FALSE
+  gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly|FALSE
+  gMinPlatformPkgTokenSpaceGuid.PcdSerialTerminalEnable|TRUE
+  gMinPlatformPkgTokenSpaceGuid.PcdSetBmcVgaToHost|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPciBusHotplugDeviceSupport|FALSE
+  gNetworkFeaturePkgTokenSpaceGuid.PcdNetworkFeatureEnable|FALSE
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootStage >= 1
+    gMinPlatformPkgTokenSpaceGuid.PcdStopAfterDebugInit|TRUE
+  !endif
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootStage >= 2
+    gMinPlatformPkgTokenSpaceGuid.PcdStopAfterDebugInit|FALSE
+    gMinPlatformPkgTokenSpaceGuid.PcdStopAfterMemInit|TRUE
+  !endif
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootStage >= 3
+    gMinPlatformPkgTokenSpaceGuid.PcdStopAfterMemInit|FALSE
+    gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly|TRUE
+  !endif
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootStage >= 4
+    gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly|FALSE
+  !endif
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootStage >= 5
+    # gMinPlatformPkgTokenSpaceGuid.PcdUefiSecureBootEnable|TRUE
+    gMinPlatformPkgTokenSpaceGuid.PcdTpm2Enable|TRUE
+    gEfiMdeModulePkgTokenSpaceGuid.PcdPciBusHotplugDeviceSupport|TRUE
+  !endif
+
+#
+# Network Advanced Features
+#
+!if gNetworkFeaturePkgTokenSpaceGuid.PcdNetworkFeatureEnable == TRUE
+  !include Network/NetworkFeaturePkg/Include/NetworkFeature.dsc
+!endif
+
+[PcdsFeatureFlag]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPciDegradeResourceForOptionRom|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdDxeIplSwitchToLongMode|TRUE
+  gEfiMdePkgTokenSpaceGuid.PcdDriverDiagnostics2Disable|TRUE
+  gEfiMdePkgTokenSpaceGuid.PcdComponentName2Disable|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdConOutGopSupport|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdConOutUgaSupport|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwarePerformanceDataTableS3Support|FALSE
+
+  #
+  # SMM
+  #
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly == FALSE
+    gUefiCpuPkgTokenSpaceGuid.PcdCpuSmmStackGuard|FALSE
+    gUefiCpuPkgTokenSpaceGuid.PcdCpuSmmEnableBspElection|FALSE
+    gUefiCpuPkgTokenSpaceGuid.PcdCpuSmmFeatureControlMsrLock|FALSE
+  !else
+    gAmdCommonPkgTokenSpaceGuid.PcdAmdSpiWriteDisable|FALSE
+  !endif
+
+  # Uefi Cpu Package
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuSmmBlockStartupThisAp|TRUE
+
+  #ACPI
+  gEfiMdeModulePkgTokenSpaceGuid.PcdInstallAcpiSdtProtocol|TRUE
+
+[PcdsFixedAtBuild.IA32]
+  #
+  # Temporary DRAM space for SEC->PEI transition (256KB)
+  # AMD_ENABLE_UEFI_STACK (Flat32.asm) divides: 1/2 Heap + 1/2 Stack
+  #
+  gAmdCommonPkgTokenSpaceGuid.PcdTempRamBase|0x00100000
+  gAmdCommonPkgTokenSpaceGuid.PcdTempRamSize|0x00100000
+
+  #
+  # Temporary stack for PEI. 0 means half of PcdTempRamSize.
+  #  Set by SecStartup() in UefiCpuPkg/SecCore/SecMain.c,
+  #  and aligned with AMD_ENABLE_UEFI_STACK.
+  gUefiCpuPkgTokenSpaceGuid.PcdPeiTemporaryRamStackSize|0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPeiCoreMaxPeiStackSize|0x80000
+
+[PcdsFixedAtBuild]
+  ## Indicate the TPM2 ACPI table revision. Rev 4 has been defined since TCG ACPI Specification Rev 00.37.<BR><BR>
+  # To support configuring from setup page, this PCD can be DynamicHii type and map to a setup option.<BR>
+  # For example, map to TCG2_VERSION.Tpm2AcpiTableRev to be configured by Tcg2ConfigDxe driver.<BR>
+  # gEfiSecurityPkgTokenSpaceGuid.PcdTpm2AcpiTableRev|L"TCG2_VERSION"|gTcg2ConfigFormSetGuid|0x8|3|NV,BS<BR>
+  # @Prompt Revision of TPM2 ACPI table.
+  gEfiSecurityPkgTokenSpaceGuid.PcdTpm2AcpiTableRev|4
+
+  ## This PCD defines initial setting of TCG2 Persistent Firmware Management Flags
+  # PCD can be configured for different settings in different scenarios
+  # This PCD follows UEFI TCG2 library definition bit of the BIOS TPM/Storage Management Flags<BR>
+  #    BIT0  -  Reserved <BR>
+  #    BIT1  -  TCG2_BIOS_TPM_MANAGEMENT_FLAG_PP_REQUIRED_FOR_CLEAR <BR>
+  #    BIT2  -  Reserved <BR>
+  #    BIT3  -  TCG2_LIB_PP_FLAG_RESET_TRACK <BR>
+  #    BIT4  -  TCG2_BIOS_TPM_MANAGEMENT_FLAG_PP_REQUIRED_FOR_TURN_ON <BR>
+  #    BIT5  -  TCG2_BIOS_TPM_MANAGEMENT_FLAG_PP_REQUIRED_FOR_TURN_OFF <BR>
+  #    BIT6  -  TCG2_BIOS_TPM_MANAGEMENT_FLAG_PP_REQUIRED_FOR_CHANGE_EPS <BR>
+  #    BIT7  -  TCG2_BIOS_TPM_MANAGEMENT_FLAG_PP_REQUIRED_FOR_CHANGE_PCRS <BR>
+  #    BIT16 -  TCG2_BIOS_STORAGE_MANAGEMENT_FLAG_PP_REQUIRED_FOR_ENABLE_BLOCK_SID <BR>
+  #    BIT17 -  TCG2_BIOS_STORAGE_MANAGEMENT_FLAG_PP_REQUIRED_FOR_DISABLE_BLOCK_SID <BR>
+  #    BIT18 -  TCG2_BIOS_STORAGE_MANAGEMENT_FLAG_ENABLE_BLOCK_SID <BR>
+  # @Prompt Initial setting of TCG2 Persistent Firmware Management Flags
+  gEfiSecurityPkgTokenSpaceGuid.PcdTcg2PhysicalPresenceFlags|0x700E0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVpdBaseAddress|0x0
+
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSrIovSupport|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAriSupport|FALSE
+
+  #!if gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly == TRUE
+    gEfiMdeModulePkgTokenSpaceGuid.PcdEmuVariableNvModeEnable|TRUE
+  #!endif
+
+  # Default Value of PlatformLangCodes Variable.
+  gEfiMdePkgTokenSpaceGuid.PcdUefiVariableDefaultPlatformLangCodes|"en-US"
+
+  ## The mask is used to control ReportStatusCodeLib behavior.
+  #  BIT0 - Enable Progress Code.
+  #  BIT1 - Enable Error Code.
+  #  BIT2 - Enable Debug Code.
+  gEfiMdePkgTokenSpaceGuid.PcdReportStatusCodePropertyMask|0x00
+
+  #
+  # Debug Masks
+  #
+  # //
+  # // Declare bits for PcdDebugPropertyMask
+  # //
+  # DEBUG_PROPERTY_DEBUG_ASSERT_ENABLED       0x01
+  # DEBUG_PROPERTY_DEBUG_PRINT_ENABLED        0x02
+  # DEBUG_PROPERTY_DEBUG_CODE_ENABLED         0x04
+  # DEBUG_PROPERTY_CLEAR_MEMORY_ENABLED       0x08
+  # DEBUG_PROPERTY_ASSERT_BREAKPOINT_ENABLED  0x10
+  # DEBUG_PROPERTY_ASSERT_DEADLOOP_ENABLED    0x20
+
+  # //
+  # // Declare bits for PcdFixedDebugPrintErrorLevel and the ErrorLevel parameter of DebugPrint()
+  # //
+  # DEBUG_INIT      0x00000001  // Initialization
+  # DEBUG_WARN      0x00000002  // Warnings
+  # DEBUG_LOAD      0x00000004  // Load events
+  # DEBUG_FS        0x00000008  // EFI File system
+  # DEBUG_POOL      0x00000010  // Alloc & Free's
+  # DEBUG_PAGE      0x00000020  // Alloc & Free's
+  # DEBUG_INFO      0x00000040  // Informational debug messages
+  # DEBUG_DISPATCH  0x00000080  // PEI/DXE/SMM Dispatchers
+  # DEBUG_VARIABLE  0x00000100  // Variable
+  # DEBUG_BM        0x00000400  // Boot Manager
+  # DEBUG_BLKIO     0x00001000  // BlkIo Driver
+  # DEBUG_NET       0x00004000  // SNI Driver
+  # DEBUG_UNDI      0x00010000  // UNDI Driver
+  # DEBUG_LOADFILE  0x00020000  // UNDI Driver
+  # DEBUG_EVENT     0x00080000  // Event messages
+  # DEBUG_GCD       0x00100000  // Global Coherency Database changes
+  # DEBUG_CACHE     0x00200000  // Memory range cachability changes
+  # DEBUG_VERBOSE   0x00400000  // Detailed debug messages that may significantly impact boot performance
+  # DEBUG_ERROR     0x80000000  // Error
+
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0x3F
+  !if $(DEBUG_DISPATCH_ENABLE)
+    gEfiMdePkgTokenSpaceGuid.PcdFixedDebugPrintErrorLevel|0x800805CF
+  !else
+    gEfiMdePkgTokenSpaceGuid.PcdFixedDebugPrintErrorLevel|0x8000004F
+  !endif
+
+  #
+  # Specifies the initial value for Register_D in RTC.
+  # Reason for change:
+  #  PcRtc.c wants to see register D bit 7 (VRT) high almost immediately after writing the below value,
+  #  which clears it with the default UEFI value of zero. The AMD FCH updates this bit only once per 4-1020ms (1020ms default).
+  #  This causes function RtcWaitToUpdate to return an error. Preset VRT to 1 to avoid this.
+  #
+  gPcAtChipsetPkgTokenSpaceGuid.PcdInitialValueRtcRegisterD|0x80
+
+  #
+  #SMBIOS
+  #
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdSmbiosT16MaximumCapacity|0x80000000
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdSmbiosSocketDesignationSocket0|"P0"
+
+  #
+  # PCIe Config-space MMIO (1MB per bus, 256MB)
+  #
+  gEfiMdePkgTokenSpaceGuid.PcdPciExpressBaseAddress|0xE0000000
+  gAmdCommonPkgTokenSpaceGuid.PcdPciExpressBaseAddressLow|0xE0000000
+  gAmdCommonPkgTokenSpaceGuid.PcdPciExpressBaseAddressHi|0x00000000
+  gAmdCommonPkgTokenSpaceGuid.PcdMmioCfgBusRange|0x00000008
+  gEfiMdePkgTokenSpaceGuid.PcdPciExpressBaseSize|0x10000000
+  # PCIe Config-space end address (PcdPciExpressBaseAddress + PcdPciExpressBaseSize)
+  gAmdCommonPkgTokenSpaceGuid.PcdPciExpressLimitAddress|0xEFFFFFFF
+  gEfiMdeModulePkgTokenSpaceGuid.PcdPcieResizableBarSupport|TRUE
+
+  #
+  # FCH UART HW Initialization
+  # 0: Initialize FCH UART 0 HW
+  # 1: Initialize FCH UART 1 HW
+  #
+  # If in Legacy IO mode, Need UART to conform to industry standard COM settings
+  # COM1: I/O port 0x3F8, IRQ 4
+  # COM2: I/O port 0x2F8, IRQ 3
+  # COM3: I/O port 0x3E8, IRQ 4
+  # COM4: I/O port 0x2E8, IRQ 3
+  !if ($(SERIAL_PORT) == "FCH_MMIO") OR ($(SERIAL_PORT) == "FCH_IO")
+    gPlatformTokenSpaceGuid.PcdFchUartPort|0
+    !if ($(SERIAL_PORT) == "FCH_IO") # Set IRQs for UART0 -> COMx
+      # UART0 is COM1/3 IRQ4
+      !if $(SERIAL_REGISTER_BASE) == 0x3F8 OR $(SERIAL_REGISTER_BASE) == 0x3E8
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart0Irq|0x04
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart1Irq|0x03
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart2Irq|0x04
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart3Irq|0x03
+      # UART0 is COM2/4 IRQ3
+      !elseif $(SERIAL_REGISTER_BASE) == 0x2F8 OR $(SERIAL_REGISTER_BASE) == 0x2E8
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart0Irq|0x03
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart1Irq|0x04
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart2Irq|0x03
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart3Irq|0x04
+      !endif
+    !endif
+  !elseif ($(SERIAL_PORT) == "BMC_SOL") OR ($(SERIAL_PORT) == "BMC_SOL_IO")
+    gPlatformTokenSpaceGuid.PcdFchUartPort|1
+    !if ($(SERIAL_PORT) == "BMC_SOL_IO") # Set IRQs for UART1 -> COMx
+      # UART1 is COM1/3 IRQ4
+      !if $(SERIAL_REGISTER_BASE) == 0x3F8 OR $(SERIAL_REGISTER_BASE) == 0x3E8
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart0Irq|0x03
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart1Irq|0x04
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart2Irq|0x03
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart3Irq|0x04
+      # UART1 is COM2/4 IRQ3
+      !elseif $(SERIAL_REGISTER_BASE) == 0x2F8 OR $(SERIAL_REGISTER_BASE) == 0x2E8
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart0Irq|0x04
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart1Irq|0x03
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart2Irq|0x04
+        gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchUart3Irq|0x03
+      !endif
+    !endif
+  !endif
+
+  #
+  # SerialPortLib (16650 UART)
+  #
+  ## Advertise that our UART is not PCI-based
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSerialPciDeviceInfo|{0xFF}
+  ## Base address of 16550 serial port registers in MMIO or I/O space.
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSerialRegisterBase|$(SERIAL_REGISTER_BASE)
+  #
+  # Set UART parameters SERIAL_REGISTER_BASE (If it's MMIO, it must >= 0x10000)
+  !if $(SERIAL_REGISTER_BASE) >= 0x10000
+    ## Indicates the 16550 serial port registers are in MMIO space, or in I/O space.
+    #   TRUE  - 16550 serial port registers are in MMIO space.
+    #   FALSE - 16550 serial port registers are in I/O space.
+    gEfiMdeModulePkgTokenSpaceGuid.PcdSerialUseMmio|TRUE
+
+    ## The number of bytes between registers in serial device.
+    gEfiMdeModulePkgTokenSpaceGuid.PcdSerialRegisterStride|4
+
+    ## UART clock frequency is for the baud rate configuration.
+    gEfiMdeModulePkgTokenSpaceGuid.PcdSerialClockRate|48000000
+  !else
+    ## Indicates the 16550 serial port registers are in MMIO space, or in I/O space.
+    #   TRUE  - 16550 serial port registers are in MMIO space.
+    #   FALSE - 16550 serial port registers are in I/O space.
+    gEfiMdeModulePkgTokenSpaceGuid.PcdSerialUseMmio|FALSE
+
+    ## The number of bytes between registers in serial device.
+    gEfiMdeModulePkgTokenSpaceGuid.PcdSerialRegisterStride|1
+
+    ## UART clock frequency is for the baud rate configuration.
+    gEfiMdeModulePkgTokenSpaceGuid.PcdSerialClockRate|1843200
+  !endif
+
+  ## Indicates if the 16550 serial port hardware flow control will be enabled. Default is FALSE.
+  #   TRUE  - 16550 serial port hardware flow control will be enabled.
+  #   FALSE - 16550 serial port hardware flow control will be disabled.
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSerialUseHardwareFlowControl|FALSE
+
+  ## Indicates if the 16550 serial Tx operations will be blocked if DSR is not asserted (no cable). Default is FALSE.
+  #  This PCD is ignored if PcdSerialUseHardwareFlowControl is FALSE.
+  #   TRUE  - 16550 serial Tx operations will be blocked if DSR is not asserted.
+  #   FALSE - 16550 serial Tx operations will not be blocked if DSR is not asserted.
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSerialDetectCable|FALSE
+
+  ## Line Control Register (LCR) for the 16550 serial port. This encodes data bits, parity, and stop bits.
+  #    BIT1..BIT0 - Data bits.  00b = 5 bits, 01b = 6 bits, 10b = 7 bits, 11b = 8 bits.
+  #    BIT2       - Stop Bits.  0 = 1 stop bit.  1 = 1.5 stop bits if 5 data bits selected, otherwise 2 stop bits.
+  #    BIT5..BIT3 - Parity.  xx0b = No Parity, 001b = Odd Parity, 011b = Even Parity, 101b = Mark Parity, 111b=Stick Parity.
+  #    BIT7..BIT6 - Reserved.  Must be 0.
+  #
+  #  Default is No Parity, 8 Data Bits, 1 Stop Bit.
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSerialLineControl|0x03
+
+  ## FIFO Control Register (FCR) for the 16550 serial port.
+  #    BIT0       - FIFO Enable.  0 = Disable FIFOs.  1 = Enable FIFOs.
+  #    BIT1       - Clear receive FIFO.  1 = Clear FIFO.
+  #    BIT2       - Clear transmit FIFO.  1 = Clear FIFO.
+  #    BIT4..BIT3 - Reserved.  Must be 0.
+  #    BIT5       - Enable 64-byte FIFO.  0 = Disable 64-byte FIFO.  1 = Enable 64-byte FIFO.
+  #    BIT7..BIT6 - Reserved.  Must be 0.<BR>
+  #
+  #  Default is to enable and clear all FIFOs.
+  !if ($(SERIAL_PORT) == "FCH_IO") OR ($(SERIAL_PORT) == "BMC_SOL_IO")
+    gEfiMdeModulePkgTokenSpaceGuid.PcdSerialFifoControl|0x00
+  !else
+    gEfiMdeModulePkgTokenSpaceGuid.PcdSerialFifoControl|0x07
+  !endif
+
+  ## Baud rate for the 16550 serial port.  Default is 115200 baud.
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSerialBaudRate|115200
+
+  #
+  # SerialDxe (uses SerialPortLib)
+  #
+  ## Indicates the default baud rate of UART.
+  # @ValidList | 115200, 57600, 38400, 19200, 9600, 7200, 4800, 3600, 2400, 2000, 1800, 1200, 600, 300, 150, 134, 110, 75, 50
+  gEfiMdePkgTokenSpaceGuid.PcdUartDefaultBaudRate|115200
+
+  ## Indicates the number of efficient data bit in UART transaction.
+  # @ValidRange | 5 - 8
+  gEfiMdePkgTokenSpaceGuid.PcdUartDefaultDataBits|8
+
+  ## Indicates the setting of data parity in UART transaction.
+  # 0 - Default Parity.
+  # 1 - No Parity.
+  # 2 - Even Parity.
+  # 3 - Odd Parity.
+  # 4 - Mark Parity.
+  # 5 - Space Parity.
+  # @ValidRange | 0 - 5
+  gEfiMdePkgTokenSpaceGuid.PcdUartDefaultParity|1
+
+  ## Indicates the setting of stop bit in UART transaction.
+  # 0 - Default Stop Bits.
+  # 1 - One Stop Bit.
+  # 2 - One Five Stop Bits.
+  # 3 - Two Stop Bits.
+  # @ValidRange | 0 - 3
+  gEfiMdePkgTokenSpaceGuid.PcdUartDefaultStopBits|1
+
+  ## Indicates the receive FIFO depth of UART controller.
+  gEfiMdePkgTokenSpaceGuid.PcdUartDefaultReceiveFifoDepth|64
+
+  #
+  # TerminalDxe
+  #
+  ## Indicates the usable type of terminal.
+  #  0 - PCANSI
+  #  1 - VT100
+  #  2 - VT100+
+  #  3 - UTF8
+  #  4 - TTYTERM, NOT defined in UEFI SPEC
+  # @ValidRange | 0 - 4
+  gEfiMdePkgTokenSpaceGuid.PcdDefaultTerminalType|0
+
+  #
+  # Boot
+  #
+  # PCDs to set the default size of the different UEFI memory types to promote
+  # contiguous UEFI memory allocation.  These values are used by
+  # AmdCommon/Pei/PlatformInitPei/MemoryInitPei.c to reserve
+  # default chunks for each memory type when gEfiMemoryTypeInformationGuid
+  # variable is not set.  These values can be updated to prevent reboot because
+  # MdeModulePkg/Library/UefiBootManagerLib/BmMisc.c:
+  # BmSetMemoryTypeInformationVariable() sets gEfiMemoryTypeInformationGuid at
+  # the end of post to reserve more memory.  Serial output from this code will
+  # display sizes required, which can then be updated in these PCDs.
+  # Memory Type 09
+  gMinPlatformPkgTokenSpaceGuid.PcdPlatformEfiAcpiReclaimMemorySize        | 0x200
+  # Memory Type 0A
+  gMinPlatformPkgTokenSpaceGuid.PcdPlatformEfiAcpiNvsMemorySize            | 0x100
+  # Memory Type 00
+  gMinPlatformPkgTokenSpaceGuid.PcdPlatformEfiReservedMemorySize           | 0x1000
+  # Memory Type 06
+  gMinPlatformPkgTokenSpaceGuid.PcdPlatformEfiRtDataMemorySize             | 0x400
+  # Memory Type 05
+  gMinPlatformPkgTokenSpaceGuid.PcdPlatformEfiRtCodeMemorySize             | 0x100
+  gEfiMdePkgTokenSpaceGuid.PcdPlatformBootTimeOut|10
+  gEfiMdeModulePkgTokenSpaceGuid.PcdConInConnectOnDemand|FALSE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdResetOnMemoryTypeInformationChange|TRUE
+  # 462CAA21-7614-4503-836E-8AB6F4662331 (UiApp FILE_GUID)
+  gEfiMdeModulePkgTokenSpaceGuid.PcdBootManagerMenuFile|{ GUID("462CAA21-7614-4503-836E-8AB6F4662331") }
+!if $(USE_1GB_PAGE_TABLES)
+  gEfiMdeModulePkgTokenSpaceGuid.PcdUse1GPageTable|TRUE
+!endif
+
+  #
+  # ACPI
+  #
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchOemEnableAcpiSwSmi|0xA0
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchOemDisableAcpiSwSmi|0xA1
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId|"AMDINC"
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemTableId|0x2020202058594E4F # "S8050    "
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemRevision|0x00000001
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorId|0x20444D41
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultCreatorRevision|0x00000001
+  gMinPlatformPkgTokenSpaceGuid.PcdFadtPreferredPmProfile|4
+  gMinPlatformPkgTokenSpaceGuid.PcdFadtIaPcBootArch|0x0000
+  gMinPlatformPkgTokenSpaceGuid.PcdFadtFlags|0x0002052D
+  gPcAtChipsetPkgTokenSpaceGuid.PcdHpetBaseAddress|0xFED00000
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdAcpiCpuSsdtProcessorScopeInSb|TRUE
+  gMinPlatformPkgTokenSpaceGuid.PcdIoApicId|0x80
+  gMinPlatformPkgTokenSpaceGuid.PcdPcIoApicCount|4
+  gMinPlatformPkgTokenSpaceGuid.PcdPcIoApicIdBase|0xF1
+  gMinPlatformPkgTokenSpaceGuid.PcdPcIoApicAddressBase|0xFEC00000
+  gMinPlatformPkgTokenSpaceGuid.PcdLocalApicAddress|0xFEE00000
+  gMinPlatformPkgTokenSpaceGuid.PcdAcpiEnableSwSmi|gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchOemEnableAcpiSwSmi
+  gMinPlatformPkgTokenSpaceGuid.PcdAcpiDisableSwSmi|gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchOemDisableAcpiSwSmi
+
+  # Max Cpu constraints
+  gMinPlatformPkgTokenSpaceGuid.PcdMaxCpuThreadCount|2
+  gMinPlatformPkgTokenSpaceGuid.PcdMaxCpuCoreCount|128
+  gMinPlatformPkgTokenSpaceGuid.PcdMaxCpuSocketCount|1
+
+  #
+  # EFI NV Storage
+  #
+  gEfiMdeModulePkgTokenSpaceGuid.PcdMaxVariableSize|0x3000
+
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdCompliantEdkIIAcpiSdtProtocol|TRUE
+
+  # AGCL FCH
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchCfgAcpiPm1EvtBlkAddr|0x800
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchCfgAcpiPm1CntBlkAddr|0x804
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchCfgAcpiPmTmrBlkAddr|0x808
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchCfgCpuControlBlkAddr|0x810
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchCfgAcpiGpe0BlkAddr|0x820
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchOemBeforePciRestoreSwSmi|0xB3
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchOemAfterPciRestoreSwSmi|0xB4
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchOemSpiUnlockSwSmi|0xB7
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdFchOemSpiLockSwSmi|0xB8
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdNumberOfPhysicalSocket|gMinPlatformPkgTokenSpaceGuid.PcdMaxCpuSocketCount
+
+  # Change MTRR defaults for 0xE0000-0xFFFFF
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFixedMtrr26C|0xFFFFFFFFFFFFFFFF
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFixedMtrr26D|0xFFFFFFFFFFFFFFFF
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFixedMtrr26E|0xFFFFFFFFFFFFFFFF
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFixedMtrr26F|0xFFFFFFFFFFFFFFFF
+
+  # Disable S3 support
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiS3Enable|FALSE
+
+  ## Toggle for whether the VariablePolicy engine should allow disabling.
+  # The engine is enabled at power-on, but the interface allows the platform to
+  # disable enforcement for servicing flexibility. If this PCD is disabled, it will block the ability to
+  # disable the enforcement and VariablePolicy enforcement will always be ON.
+  #   TRUE - VariablePolicy can be disabled by request through the interface (until interface is locked)
+  #   FALSE - VariablePolicy interface will not accept requests to disable and is ALWAYS ON
+  # @Prompt Allow VariablePolicy enforcement to be disabled.
+  gEfiMdeModulePkgTokenSpaceGuid.PcdAllowVariablePolicyEnforcementDisable|TRUE
+
+  #
+  # FALSE: The board is not a FSP wrapper (FSP binary not used)
+  # TRUE:  The board is a FSP wrapper (FSP binary is used)
+  #
+  gMinPlatformPkgTokenSpaceGuid.PcdFspWrapperBootMode|FALSE
+
+  # TRUE  - 5-Level Paging will be enabled.
+  # FALSE - 5-Level Paging will not be enabled.
+  gEfiMdeModulePkgTokenSpaceGuid.PcdUse5LevelPageTable|FALSE
+
+  # Specifies stack size in bytes for each processor in SMM.
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuSmmStackSize|0x4000
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdAcpiTableHeaderOemId|gEfiMdeModulePkgTokenSpaceGuid.PcdAcpiDefaultOemId
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdAmdMemMaxSocketSupportedV2|1
+
+  # Secureboot
+  !if gMinPlatformPkgTokenSpaceGuid.PcdUefiSecureBootEnable == TRUE
+    gEfiSecurityPkgTokenSpaceGuid.PcdUserPhysicalPresence|TRUE
+  !endif
+
+[PcdsDynamicDefault.common]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdStatusCodeUseSerial|TRUE
+  gEfiMdeModulePkgTokenSpaceGuid.PcdStatusCodeUseMemory|FALSE
+
+  #
+  # Set video resolution.
+  #
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVideoHorizontalResolution|1024
+  gEfiMdeModulePkgTokenSpaceGuid.PcdVideoVerticalResolution|768
+
+  #
+  # Account for 1P configuration (256 threads per socket)
+  #
+  gUefiCpuPkgTokenSpaceGuid.PcdCpuMaxLogicalProcessorNumber|256
+
+  #
+  # Set MMIO Above4GB at the 1TB boundary
+  #
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdMmioAbove4GLimit|0x7FBFFFFFFFF
+
+  #
+  # The base address of temporary page table for accessing PCIE MMIO base address above 4G in PEI phase.
+  #
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdPeiTempPageTableBaseAddress|0x60000000
+
+  # IO Resource padding in bytes, default 4KB, override to 0.
+  gAmdCommonPkgTokenSpaceGuid.PcdPciHotPlugResourcePadIO|0x00
+
+  #
+  # Flash NV Storage
+  #
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableBase64|0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingBase64|0
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareBase64|0
+
+  #
+  # AGESA FCH
+  #
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdLegacyFree|FALSE
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdHpetEnable|TRUE
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdHpetMsiDis|FALSE
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdNativePcieSupport|TRUE
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdNoneSioKbcSupport|TRUE
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdCfgFchIoapicId|gMinPlatformPkgTokenSpaceGuid.PcdIoApicId
+
+  # Tell AGCL how you want the UART configured for serial output
+  # FchRTDeviceEnableMap
+  # < BIT4 - LPC : PcdLpcEnable
+  # < BIT5 - I2C0 : FchRTDeviceEnableMap[BIT5]
+  # < BIT6 - I2C1 : FchRTDeviceEnableMap[BIT6]
+  # < BIT7 - I2C2 : FchRTDeviceEnableMap[BIT7]
+  # < BIT8 - I2C3 : FchRTDeviceEnableMap[BIT8]
+  # < BIT9 - I2C4 : FchRTDeviceEnableMap[BIT9]
+  # < BIT10 - I2C5 : FchRTDeviceEnableMap[BIT10]
+  # < BIT11 - UART0 : FchRTDeviceEnableMap[BIT11]
+  # < BIT12 - UART1 : FchRTDeviceEnableMap[BIT12]
+  # < BIT16 - UART2 : FchRTDeviceEnableMap[BIT13]
+  # < BIT18 - SD : PcdEmmcEnable and PcdEmmcType < 5
+  # < BIT26 - UART3 : FchRTDeviceEnableMap[BIT26]
+  # < BIT27 - eSPI : PcdEspiEnable - read-only.
+  # < BIT28 - eMMC : PcdEmmcEnable - read-only.
+  !if ($(SERIAL_PORT) == "FCH_MMIO") OR ($(SERIAL_PORT) == "FCH_IO")
+    gEfiAmdAgesaModulePkgTokenSpaceGuid.FchRTDeviceEnableMap|0x00000800
+  !elseif ($(SERIAL_PORT) == "BMC_SOL") OR ($(SERIAL_PORT) == "BMC_SOL_IO")
+    gEfiAmdAgesaModulePkgTokenSpaceGuid.FchRTDeviceEnableMap|0x00001000
+  !endif
+  # FchUartLegacyEnable
+  # 0-disable, 1- 0x2E8/2EF, 2 - 0x2F8/2FF, 3 - 0x3E8/3EF, 4 - 0x3F8/3FF
+  !if $(SERIAL_PORT) == "FCH_IO"
+    !if $(SERIAL_REGISTER_BASE) == 0x2E8
+      gEfiAmdAgesaPkgTokenSpaceGuid.FchUart0LegacyEnable|0x01
+    !elseif $(SERIAL_REGISTER_BASE) == 0x2F8
+      gEfiAmdAgesaPkgTokenSpaceGuid.FchUart0LegacyEnable|0x02
+    !elseif $(SERIAL_REGISTER_BASE) == 0x3E8
+      gEfiAmdAgesaPkgTokenSpaceGuid.FchUart0LegacyEnable|0x03
+    !elseif $(SERIAL_REGISTER_BASE) == 0x3F8
+      gEfiAmdAgesaPkgTokenSpaceGuid.FchUart0LegacyEnable|0x04
+    !endif
+  !elseif  $(SERIAL_PORT) == "BMC_SOL_IO"
+    !if $(SERIAL_REGISTER_BASE) == 0x2E8
+      gEfiAmdAgesaPkgTokenSpaceGuid.FchUart1LegacyEnable|0x01
+    !elseif $(SERIAL_REGISTER_BASE) == 0x2F8
+      gEfiAmdAgesaPkgTokenSpaceGuid.FchUart1LegacyEnable|0x02
+    !elseif $(SERIAL_REGISTER_BASE) == 0x3E8
+      gEfiAmdAgesaPkgTokenSpaceGuid.FchUart1LegacyEnable|0x03
+    !elseif $(SERIAL_REGISTER_BASE) == 0x3F8
+      gEfiAmdAgesaPkgTokenSpaceGuid.FchUart1LegacyEnable|0x04
+    !endif
+  !endif
+
+  #
+  # AGCL BMC (NBIO)
+  #
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdEarlyBmcLinkTraining|TRUE
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdEarlyBmcLinkSocket|0
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdEarlyBmcLinkDie|0
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdEarlyBmcLinkLaneNum|134
+
+  #
+  # AGCL USB
+  #
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdXhciOcPolarityCfgLow|TRUE
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdXhciUsb31OcPinSelect|0xFFFF1010
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdXhciUsb20OcPinSelect|0xFFFFFFFFFFFF1010
+
+  !if $(USB_SUPPORT)
+    ### USB 3.0 controller0
+    gEfiAmdAgesaPkgTokenSpaceGuid.PcdXhci0Enable|TRUE
+    ### USB 3.0 controller1
+    gEfiAmdAgesaPkgTokenSpaceGuid.PcdXhci1Enable|TRUE
+    ### USB3.0 controller0 on MCM-1
+    gEfiAmdAgesaPkgTokenSpaceGuid.PcdXhci2Enable|FALSE
+    ### USB3.0 controller1 on MCM-1
+    gEfiAmdAgesaPkgTokenSpaceGuid.PcdXhci3Enable|FALSE
+
+    gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdXhciSsid|0x00000000
+    gEfiAmdAgesaPkgTokenSpaceGuid.PcdXhciECCDedErrRptEn|FALSE
+  !else
+    ### USB 3.0 controller0
+    gEfiAmdAgesaPkgTokenSpaceGuid.PcdXhci0Enable|FALSE
+    ### USB 3.0 controller1
+    gEfiAmdAgesaPkgTokenSpaceGuid.PcdXhci1Enable|FALSE
+    ### USB3.0 controller0 on MCM-1
+    gEfiAmdAgesaPkgTokenSpaceGuid.PcdXhci2Enable|FALSE
+    ### USB3.0 controller1 on MCM-1
+    gEfiAmdAgesaPkgTokenSpaceGuid.PcdXhci3Enable|FALSE
+  !endif
+
+!if $(SATA_SUPPORT)
+  ### @brief FCH-SATA enables
+  ### @details Select whether or not the FCH Sata controller is active.
+  ### @li  TRUE  - This option is active.
+  ### @li  FALSE - This option is turned off.
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdSataEnable|TRUE
+
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdSataStaggeredSpinup|TRUE
+
+  ### @brief Sata Port ESP Enables
+  ### @details Die1, Die2, etc. Port 0-7 ESP
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdSataMultiDiePortESP|0x000000000000FFFF
+!else
+  ### @brief FCH-SATA enables
+  ### @details Select whether or not the FCH Sata controller is active.
+  ### @li  TRUE  - This option is active.
+  ### @li  FALSE - This option is turned off.
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdSataEnable|FALSE
+!endif
+ #
+ # This is a work-around to be removed possibly, we need or sata will cause a hang
+ # during FchInitLate when FchInitLateSata () is called in controller SATA2
+ #
+ gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdSataControllerAutoShutdown|FALSE
+  #
+  # Set Package Power Tracking Limit
+  #
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdCfgPlatformPPT|400
+
+  #
+  # Firmware Revision
+  #
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVendor|L"AMD"
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareRevision|$(FIRMWARE_REVISION_NUM)
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareVersionString|L"$(FIRMWARE_VERSION_STR)"
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFirmwareReleaseDateString|L"$(RELEASE_DATE)"
+
+  !if $(DISABLE_SMT)
+    gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdSmtMode|0x0
+  !endif
+
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdNvdimmEnable|FALSE
+
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdAmdApicMode|0xFF
+  # MinPlatformPkg
+  gMinPlatformPkgTokenSpaceGuid.PcdPcIoApicEnable|0x0F
+  gMinPlatformPkgTokenSpaceGuid.PcdAcpiGpe0BlockAddress|gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchCfgAcpiGpe0BlkAddr
+  gMinPlatformPkgTokenSpaceGuid.PcdAcpiGpe1BlockAddress|0
+  gMinPlatformPkgTokenSpaceGuid.PcdAcpiPm1AControlBlockAddress|gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchCfgAcpiPm1CntBlkAddr
+  gMinPlatformPkgTokenSpaceGuid.PcdAcpiPm1AEventBlockAddress|gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchCfgAcpiPm1EvtBlkAddr
+  gMinPlatformPkgTokenSpaceGuid.PcdAcpiPm1BControlBlockAddress|0
+  gMinPlatformPkgTokenSpaceGuid.PcdAcpiPm1BEventBlockAddress|0
+  gMinPlatformPkgTokenSpaceGuid.PcdAcpiPm2ControlBlockAddress|0
+  gMinPlatformPkgTokenSpaceGuid.PcdAcpiPmTimerBlockAddress|gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchCfgAcpiPmTmrBlkAddr
+
+[PcdsPatchableInModule]
+    gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel|gEfiMdePkgTokenSpaceGuid.PcdFixedDebugPrintErrorLevel
+
+[PcdsDynamicHii.X64.DEFAULT]
+!if gMinPlatformPkgTokenSpaceGuid.PcdTpm2Enable == TRUE
+  gEfiSecurityPkgTokenSpaceGuid.PcdTcgPhysicalPresenceInterfaceVer|L"TCG2_VERSION"|gTcg2ConfigFormSetGuid|0x0|"1.3"|NV,BS
+  gEfiSecurityPkgTokenSpaceGuid.PcdTpm2AcpiTableRev|L"TCG2_VERSION"|gTcg2ConfigFormSetGuid|0x8|4|NV,BS
+!endif
+
+[PcdsDynamicDefault]
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdLegacyFree|TRUE
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdMemPostPackageRepair|TRUE
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdCxlProtocolErrorReporting|1
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdCxlComponentErrorReporting|1
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdEgressPoisonSeverityLo|0
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdEgressPoisonSeverityHi|0
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdXhciECCDedErrRptEn|TRUE
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdAmdS3LibTableSize|0x100000
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdPspAntiRollbackLateSplFuse|TRUE
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdUsbSspOemConfigurationTable|{0x0D, 0x02, 0x50, 0x00, 0x03, 0x03, 0x03, 0x03, 0x00, 0x01, 0x06, 0x03, 0x01, 0x03, 0x03, 0x03, 0x03, 0x00, 0x01, 0x06, 0x03, 0x01, 0x03, 0x03, 0x03, 0x03, 0x00, 0x01, 0x06, 0x03, 0x01, 0x03, 0x03, 0x03, 0x03, 0x00, 0x01, 0x06, 0x03, 0x01, 0x00, 0xFF, 0x03, 0x03, 0x03, 0x03, 0x00, 0x01, 0x06, 0x03, 0x01,0x03, 0x03, 0x03, 0x03, 0x00, 0x01, 0x06, 0x03, 0x01,0x03, 0x03, 0x03, 0x03, 0x00, 0x01, 0x06, 0x03, 0x01,0x03, 0x03, 0x03, 0x03, 0x00, 0x01, 0x06, 0x03, 0x01, 0x00, 0x00}
+
+  # AGCL DMAr protection
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdCfgIommuSupport|TRUE
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdIvInfoDmaReMap|FALSE
+
+  # Enable CState
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdCStateMode|1
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdCStateIoBaseAddress|0x813
+
+  # AGCL I2C SDA hold delay
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchI2c0SdaHold|0x35
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchI2c1SdaHold|0x35
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchI2c2SdaHold|0x35
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchI2c3SdaHold|0x35
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchI2c4SdaHold|0x35
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchI2c5SdaHold|0x35
+
+  gEfiAmdAgesaModulePkgTokenSpaceGuid.PcdResetMode|0x07
+
+  # According to ACPI 6.4 porting guide
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdFchCfgSmiCmdPortAddr|0xB2
+
+!if gMinPlatformPkgTokenSpaceGuid.PcdTpm2Enable == TRUE
+  ## This PCD indicates the initialization policy for TPM 1.2.<BR><BR>
+  #  If 0, no initialization needed - most likely used for chipset SRTM solution, in which TPM is already initialized.<BR>
+  #  If 1, initialization needed.<BR>
+  # @Prompt TPM 1.2 device initialization policy.
+  # @ValidRange 0x80000001 | 0x00 - 0x1
+  gEfiSecurityPkgTokenSpaceGuid.PcdTpmInitializationPolicy|1
+
+  ## Guid name to identify TPM instance.<BR><BR>
+  #  TPM_DEVICE_INTERFACE_NONE means disable.<BR>
+  #  TPM_DEVICE_INTERFACE_TPM12 means TPM 1.2 DTPM.<BR>
+  #  TPM_DEVICE_INTERFACE_DTPM2 means TPM 2.0 DTPM.<BR>
+  #  Other GUID value means other TPM 2.0 device.<BR>
+  # @Prompt TPM device type identifier
+  gEfiSecurityPkgTokenSpaceGuid.PcdTpmInstanceGuid|{GUID({ 0x286bf25a, 0xc2c3, 0x408c, { 0xb3, 0xb4, 0x25, 0xe6, 0x75, 0x8b, 0x73, 0x17 } })}
+
+  ## This PCD is to control which device is the potential trusted console input device.<BR><BR>
+  # For example:<BR>
+  # USB Short Form: UsbHID(0xFFFF,0xFFFF,0x1,0x1)<BR>
+  #   //Header                    VendorId    ProductId   Class SubClass Protocol<BR>
+  #     {0x03, 0x0F, 0x0B, 0x00,  0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x01,    0x01,<BR>
+  #   //Header<BR>
+  #      0x7F, 0xFF, 0x04, 0x00}<BR>
+  gMinPlatformPkgTokenSpaceGuid.PcdTrustedConsoleInputDevicePath|{DEVICE_PATH("VenHw(D3987D4B-971A-435F-8CAF-4967EB627241)/Uart(115200,8,N,1)/VenMsg(E0C14753-F9BE-11D2-9A0C-0090273FC14D),UsbClass(0xFFFF,0xFFFF,0x03,0x01,0x01)")}
+
+  ## This PCD is to control which device is the potential trusted console output device.<BR><BR>
+  # For example:<BR>
+  # Integrated Graphic: PciRoot(0x0)/Pci(0x2,0x0)<BR>
+  #   //Header                    HID                     UID<BR>
+  #     {0x02, 0x01, 0x0C, 0x00,  0xd0, 0x41, 0x03, 0x0A, 0x00, 0x00, 0x00, 0x00,<BR>
+  #   //Header                    Func  Dev<BR>
+  #      0x01, 0x01, 0x06, 0x00,  0x00, 0x02,
+  #   //Header<BR>
+  #      0x7F, 0xFF, 0x04, 0x00}<BR>
+  gMinPlatformPkgTokenSpaceGuid.PcdTrustedConsoleOutputDevicePath|{DEVICE_PATH("VenHw(D3987D4B-971A-435F-8CAF-4967EB627241)/Uart(115200,8,N,1)/VenMsg(E0C14753-F9BE-11D2-9A0C-0090273FC14D),PcieRoot(0xB)/Pci(0x05,0x02)/Pci(0x00,0x00)/Pci(0x00,0x00)/Pci(0x00,0x00)/AcpiAdr(0x80010100)")}
+  ## This PCD indicates current active TPM interface type.
+  #  According to TCG PTP spec 1.3, there are 3 types defined in TPM2_PTP_INTERFACE_TYPE.<BR>
+  #  0x00 - FIFO interface as defined in TIS 1.3 is active.<BR>
+  #  0x01 - FIFO interface as defined in PTP for TPM 2.0 is active.<BR>
+  #  0x02 - CRB interface is active.<BR>
+  #  0xFF - Contains no current active TPM interface type.<BR>
+  #
+  # @Prompt current active TPM interface type.
+  gEfiSecurityPkgTokenSpaceGuid.PcdActiveTpmInterfaceType|0x00
+!endif
+
+[PcdsDynamicExDefault]
+  #MCTP
+  gEfiAmdAgesaPkgTokenSpaceGuid.PcdAmdMCTPEnable|TRUE
+
+#######################################
+# Library Includes
+#######################################
+!include MinPlatformPkg/Include/Dsc/CoreCommonLib.dsc
+!include MinPlatformPkg/Include/Dsc/CorePeiLib.dsc
+!include MinPlatformPkg/Include/Dsc/CoreDxeLib.dsc
+
+[LibraryClasses.common]
+  #####################################
+  # Platform Package
+  #####################################
+  ReportFvLib|AmdCommonPkg/Library/PeiReportFvLib/PeiReportFvLib.inf
+  TestPointCheckLib|MinPlatformPkg/Test/Library/TestPointCheckLibNull/TestPointCheckLibNull.inf
+  PlatformBootManagerLib|MinPlatformPkg/Bds/Library/DxePlatformBootManagerLib/DxePlatformBootManagerLib.inf
+  LocalApicLib|AmdCommonPkg/Library/BaseXApicX2ApicLib/BaseXApicX2ApicLib.inf
+  PcieResourcesLib|AgesaModulePkg/Library/PcieResourcesLib/PcieResourcesLib.inf
+  FabricResourceManagerLib|AgesaModulePkg/Library/FabricResourceManagerGenoaLib/FabricResourceManagerLib.inf
+  IpmiBaseLib|AmdCommonPkg/Ipmi/Library/AmdIpmiLib/AmdIpmiLib.inf
+  PciSegmentLib|MdePkg/Library/PciSegmentLibSegmentInfo/BasePciSegmentLibSegmentInfo.inf
+
+[LibraryClasses]
+  #
+  # Base
+  #
+  !if $(LOGGING_ENABLE)
+    DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+  !else
+    DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
+  !endif
+  !if $(SOURCE_DEBUG_ENABLE)
+    DebugCommunicationLib|SourceLevelDebugPkg/Library/DebugCommunicationLibSerialPort/DebugCommunicationLibSerialPort.inf
+    PeCoffExtraActionLib|SourceLevelDebugPkg/Library/PeCoffExtraActionLibDebug/PeCoffExtraActionLibDebug.inf
+  !else
+    PeCoffExtraActionLib|MdePkg/Library/BasePeCoffExtraActionLibNull/BasePeCoffExtraActionLibNull.inf
+  !endif
+  PciLib|MdePkg/Library/BasePciLibPciExpress/BasePciLibPciExpress.inf
+  PciSegmentInfoLib|MinPlatformPkg/Pci/Library/PciSegmentInfoLibSimple/PciSegmentInfoLibSimple.inf
+
+  #
+  # Generic Modules
+  #
+  SmbusLib|MdePkg/Library/DxeSmbusLib/DxeSmbusLib.inf
+
+!if $(CAPSULE_ENABLE)
+  CapsuleLib|MdeModulePkg/Library/DxeCapsuleLibFmp/DxeCapsuleLib.inf
+!else
+  CapsuleLib|MdeModulePkg/Library/DxeCapsuleLibNull/DxeCapsuleLibNull.inf
+!endif
+
+  #
+  # Platform-specific
+  #
+  PlatformSecLib|AmdCommonPkg/Library/PlatformSecLib/PlatformSecLib.inf
+!if $(SERIAL_PORT) == "NONE"
+  SerialPortLib|MdePkg/Library/BaseSerialPortLibNull/BaseSerialPortLibNull.inf
+!else
+  SerialPortLib|MdeModulePkg/Library/BaseSerialPortLib16550/BaseSerialPortLib16550.inf
+  !if $(SERIAL_PORT) == "BMC_ESPI"
+    PlatformHookLib|MdeModulePkg/Library/BasePlatformHookLibNull/BasePlatformHookLibNull.inf
+  !else
+    PlatformHookLib|MiTACCommonPkg/Library/PlatformHookLib/BasePlatformHookLibAST2600/BasePlatformHookLibAST2600.inf
+  !endif
+!endif
+  TimerLib|AmdCommonPkg/Library/TscTimerLib/DxeTscTimerLib.inf
+  PciHostBridgeLib|AgesaModulePkg/Library/DxeAmdPciHostBridgeLib/PciHostBridgeLib.inf
+  AcpiSdtParserLib|AmdCommonPkg/Library/DxeAcpiSdtParserLib/DxeAcpiSdtParserLib.inf
+  AslUpdateLib|MinPlatformPkg/Acpi/Library/DxeAslUpdateLib/DxeAslUpdateLib.inf
+  BoardAcpiTableLib|MinPlatformPkg/Acpi/Library/BoardAcpiTableLibNull/BoardAcpiTableLibNull.inf
+
+  #
+  # AMD AML
+  #
+  AmlLib|AmdCommonPkg/Library/DxeAmdAmlLib/AmlLib.inf
+
+!if $(UNIT_TEST_AMD_AML_ENABLE)
+  UnitTestLib|UnitTestFrameworkPkg/Library/UnitTestLib/UnitTestLib.inf
+  UnitTestPersistenceLib|UnitTestFrameworkPkg/Library/UnitTestPersistenceLibNull/UnitTestPersistenceLibNull.inf
+  UnitTestResultReportLib|UnitTestFrameworkPkg/Library/UnitTestResultReportLib/UnitTestResultReportLibDebugLib.inf
+!endif
+  BootLogoLib|MdeModulePkg/Library/BootLogoLib/BootLogoLib.inf
+
+[LibraryClasses.common.SEC]
+  #
+  # SEC specific phase
+  #
+  TimerLib|AmdCommonPkg/Library/TscTimerLib/BaseTscTimerLib.inf
+
+[LibraryClasses.IA32.PEIM,LibraryClasses.IA32.PEI_CORE]
+  #
+  # PEI phase common
+  #
+  TimerLib|AmdCommonPkg/Library/TscTimerLib/PeiTscTimerLib.inf
+  ResetSystemLib|MdeModulePkg/Library/PeiResetSystemLib/PeiResetSystemLib.inf
+
+[LibraryClasses.common.PEIM]
+  SetCacheMtrrLib|AmdCommonPkg/Library/SetCacheMtrrLib/SetCacheMtrrLib.inf
+  ReportCpuHobLib|AmdCommonPkg/Library/ReportCpuHobLib/ReportCpuHobLib.inf
+  # AGCL FCH Platform/OEM hook
+  FchInitHookLibPei|AmdCommonPkg/Library/FchInitHookLib/FchInitHookLibPei.inf
+
+  libAMDxPRF|AmdOpenSilPkg/opensil-uefi-interface/libAMDxPRF.inf
+  libAMDxSIM|AmdOpenSilPkg/opensil-uefi-interface/libF19M10xSIM.inf
+  libAMDxUSL|AmdOpenSilPkg/opensil-uefi-interface/libAMDxUSL.inf
+  SilEfiLib|AmdOpenSilPkg/opensil-uefi-interface/SilToUefi/SilEfiPI72.inf
+  SilPeiInit|AmdOpenSilPkg/opensil-uefi-interface/Platform/SilPei.inf
+
+[LibraryClasses.IA32.SEC]
+  #####################################
+  # Platform Package
+  #####################################
+  SetCacheMtrrLib|MinPlatformPkg/Library/SetCacheMtrrLib/SetCacheMtrrLibNull.inf
+  ReportCpuHobLib|AmdCommonPkg/Library/ReportCpuHobLib/ReportCpuHobLib.inf
+
+[LibraryClasses.common.SEC, LibraryClasses.common.PEIM, LibraryClasses.common.PEI_CORE]
+  PciLib|MdePkg/Library/PeiPciLibPciCfg2/PeiPciLibPciCfg2.inf
+  PciSegmentLib|MdePkg/Library/PeiPciSegmentLibPciCfg2/PeiPciSegmentLibPciCfg2.inf
+
+[LibraryClasses.Common.DXE_DRIVER]
+  SmbiosMiscLib|$(PROCESSOR_PATH)/$(PLATFORM_NAME)/Library/SmbiosMiscLib/SmbiosMiscLib.inf
+  libAMDxPRF|AmdOpenSilPkg/opensil-uefi-interface/libAMDxPRF.inf
+  libAMDxSIM|AmdOpenSilPkg/opensil-uefi-interface/libF19M10xSIM.inf
+  libAMDxUSL|AmdOpenSilPkg/opensil-uefi-interface/libAMDxUSL.inf
+  SilEfiLib|AmdOpenSilPkg/opensil-uefi-interface/SilToUefi/SilEfiPI72.inf
+  SilDxeInit|AmdOpenSilPkg/opensil-uefi-interface/Platform/SilDxe.inf
+
+[LibraryClasses.Common.DXE_CORE, LibraryClasses.Common.DXE_DRIVER, LibraryClasses.Common.DXE_SMM_DRIVER]
+  TimerLib|AmdCommonPkg/Library/TscTimerLib/DxeTscTimerLib.inf
+  BoardBdsHookLib|AmdBoardPkg/Library/BoardBdsHookLib/BoardBdsHookLib.inf
+  BoardBootManagerLib|BoardModulePkg/Library/BoardBootManagerLib/BoardBootManagerLib.inf
+  libAMDxSIM|AmdOpenSilPkg/opensil-uefi-interface/libF19M10xSIM.inf
+  libAMDxUSL|AmdOpenSilPkg/opensil-uefi-interface/libAMDxUSL.inf
+  SilEfiLib|AmdOpenSilPkg/opensil-uefi-interface/SilToUefi/SilEfiPI72.inf
+
+[LibraryClasses.Common.DXE_SMM_DRIVER]
+!if $(RUNTIME_LOGGING_ENABLE)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
+!endif
+
+[LibraryClasses.Common.SMM_CORE]
+SmmCorePlatformHookLib|AmdCommonPkg/Library/SmmCorePlatformHookLib/SmmCorePlatformHookLib.inf
+!if $(RUNTIME_LOGGING_ENABLE)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
+!endif
+
+[LibraryClasses.Common.DXE_RUNTIME_DRIVER, LibraryClasses.Common.UEFI_DRIVER]
+  TimerLib|AmdCommonPkg/Library/TscTimerLib/DxeTscTimerLib.inf
+  TimerLib|AmdCommonPkg/Library/TscTimerLib/DxeTscTimerLib.inf
+  ResetSystemLib|Platform/AmdCommonPkg/Library/DxeRuntimeResetSystemLib/DxeRuntimeResetSystemLib.inf
+  libAMDxSIM|AmdOpenSilPkg/opensil-uefi-interface/libF19M10xSIM.inf
+  libAMDxUSL|AmdOpenSilPkg/opensil-uefi-interface/libAMDxUSL.inf
+  SilEfiLib|AmdOpenSilPkg/opensil-uefi-interface/SilToUefi/SilEfiPI72.inf
+
+[LibraryClasses.Common.DXE_RUNTIME_DRIVER]
+  PciSegmentLib|MdePkg/Library/PciSegmentLibSegmentInfo/DxeRuntimePciSegmentLibSegmentInfo.inf
+
+!if $(CAPSULE_ENABLE)
+  CapsuleLib|MdeModulePkg/Library/DxeCapsuleLibFmp/DxeRuntimeCapsuleLib.inf
+!endif
+
+!if $(RUNTIME_LOGGING_ENABLE)
+  DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+!else
+  DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
+!endif
+
+[LibraryClasses.Common.UEFI_DRIVER,LibraryClasses.Common.UEFI_APPLICATION]
+  UefiShellBcfgCommandLib|ShellPkg/Library/UefiShellBcfgCommandLib/UefiShellBcfgCommandLib.inf
+
+###################################################################################################
+#
+# Components Section - list of the modules and components that will be processed by compilation
+#                      tools and the EDK II tools to generate PE32/PE32+/Coff image files.
+#
+# Note: The EDK II DSC file is not used to specify how compiled binary images get placed
+#       into firmware volume images. This section is just a list of modules to compile from
+#       source into UEFI-compliant binaries.
+#       It is the FDF file that contains information on combining binary files into firmware
+#       volume images, whose concept is beyond UEFI and is described in PI specification.
+#       Binary modules do not need to be listed in this section, as they should be
+#       specified in the FDF file. For example: Shell binary (Shell_Full.efi), FAT binary (Fat.efi),
+#       Logo (Logo.bmp), and etc.
+#       There may also be modules listed in this section that are not required in the FDF file,
+#       When a module listed here is excluded from FDF file, then UEFI-compliant binary will be
+#       generated for it, but the binary will not be put into any firmware volume.
+#
+###################################################################################################
+
+[Components.IA32]
+  !include MinPlatformPkg/Include/Dsc/CorePeiInclude.dsc
+  MdeModulePkg/Universal/PcatSingleSegmentPciCfg2Pei/PcatSingleSegmentPciCfg2Pei.inf {
+    <LibraryClasses>
+      NULL|AmdCommonPkg/Library/BaseAlwaysFalseDepexLib/BaseAlwaysFalseDepexLib.inf
+  }
+  #DebugLib instance may use PciLib and PciLib uses gEfiPciCfg2PpiGuid.
+  #Including active DebugLib can cause problems.
+  AgesaPkg/Addendum/PciSegments/PciExpressPciCfg2/PciExpressPciCfg2.inf {
+    <LibraryClasses>
+      DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
+  }
+  $(PROCESSOR_PATH)/Pei/AmdPlatformPei.inf
+
+  #
+  # SEC Core
+  #
+  UefiCpuPkg/SecCore/SecCore.inf {
+    <LibraryClasses>
+      SecBoardInitLib|MinPlatformPkg/PlatformInit/Library/SecBoardInitLibNull/SecBoardInitLibNull.inf
+  }
+  #
+  # PEIM
+  #
+  MdeModulePkg/Universal/StatusCodeHandler/Pei/StatusCodeHandlerPei.inf {
+    <LibraryClasses>
+    !if $(LOGGING_ENABLE)
+      DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+    !else
+      DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
+    !endif
+  }
+  MdeModulePkg/Universal/ResetSystemPei/ResetSystemPei.inf
+  MdeModulePkg/Universal/CapsulePei/CapsulePei.inf
+
+  #######################################
+  # Platform Package
+  #######################################
+  MinPlatformPkg/PlatformInit/ReportFv/ReportFvPei.inf
+  MinPlatformPkg/PlatformInit/PlatformInitPei/PlatformInitPreMem.inf {
+    <LibraryClasses>
+      BoardInitLib|AmdBoardPkg/Library/BoardInitLib/PeiBoardInitPreMemLib.inf
+  }
+  MinPlatformPkg/PlatformInit/PlatformInitPei/PlatformInitPostMem.inf {
+    <LibraryClasses>
+      BoardInitLib|MinPlatformPkg/PlatformInit/Library/BoardInitLibNull/BoardInitLibNull.inf
+  }
+
+  # NVMe
+  # MdeModulePkg/Bus/Pci/NvmExpressPei/NvmExpressPei.inf
+
+  # Security
+  !if gMinPlatformPkgTokenSpaceGuid.PcdTpm2Enable == TRUE
+    MinPlatformPkg/Tcg/Tcg2PlatformPei/Tcg2PlatformPei.inf
+  !endif
+
+  # OPENSIL
+  AmdOpenSilPkg/opensil-uefi-interface/Platform/S8050-Genoa/Pei/SilS8050Pei.inf {
+    <LibraryClasses>
+      AmdOemInitS8050Lib|AgesaPkg/Addendum/Oem/S8050/Pei/AmdOemInitS8050Lib.inf
+  }
+
+
+  # IPMI
+  AmdCommonPkg/Ipmi/AmdIpmiPei/AmdIpmiPei.inf
+
+[Components.X64]
+  !include MinPlatformPkg/Include/Dsc/CoreDxeInclude.dsc
+  #
+  # DXE Core
+  #
+!if $(SOURCE_DEBUG_ENABLE)
+  SourceLevelDebugPkg/DebugAgentDxe/DebugAgentDxe.inf {
+    <LibraryClasses>
+      DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/DxeDebugAgentLib.inf
+  }
+!endif
+
+
+  #
+  # EDK Core modules
+  #
+  UefiCpuPkg/CpuDxe/CpuDxe.inf
+  MdeModulePkg/Universal/SectionExtractionDxe/SectionExtractionDxe.inf
+
+  #
+  # SPI
+  #
+  AmdCommonPkg/Spi/AmdSpiHc/AmdSpiHcDxe.inf
+  AmdCommonPkg/Spi/BoardSpiConfig/BoardSpiConfigDxe.inf
+  AmdCommonPkg/Spi/BoardSpiBus/BoardSpiBusDxe.inf
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly == FALSE
+    AmdCommonPkg/Spi/BoardSpiConfig/BoardSpiConfigSmm.inf
+    AmdCommonPkg/Spi/BoardSpiBus/BoardSpiBusSmm.inf
+    AmdCommonPkg/Spi/AmdSpiHc/AmdSpiHcSmm.inf
+    AmdCommonPkg/Spi/SpiNorFlashJedec/SpiNorFlashSmm.inf
+    AmdCommonPkg/Spi/AmdSpiFvb/AmdSpiFvbSmm.inf
+  !else
+    AmdCommonPkg/Spi/SpiNorFlashJedec/SpiNorFlashDxe.inf
+    AmdCommonPkg/Spi/AmdSpiFvb/AmdSpiFvbDxe.inf
+  !endif
+
+  #
+  # Platform
+  #
+  MinPlatformPkg/PlatformInit/PlatformInitDxe/PlatformInitDxe.inf {
+  <LibraryClasses>
+    BoardInitLib|AmdBoardPkg/Library/DxeBoardInitLib/DxeBoardInitLib.inf
+  }
+
+  #
+  # Platform Common
+  #
+  AmdCommonPkg/Hii/HiiConfigRouting/AmdConfigRouting.inf
+
+  #
+  # PCI
+  #
+  MdeModulePkg/Bus/Pci/PciHostBridgeDxe/PciHostBridgeDxe.inf
+  MdeModulePkg/Bus/Pci/PciBusDxe/PciBusDxe.inf
+
+  #
+  # USB
+  #
+!if $(USB_SUPPORT)
+  MdeModulePkg/Bus/Usb/UsbMouseDxe/UsbMouseDxe.inf
+!endif
+
+  #
+  # NVME
+  #
+  MdeModulePkg/Bus/Pci/NvmExpressDxe/NvmExpressDxe.inf
+
+  #
+  # SATA
+  #
+!if $(SATA_SUPPORT)
+  MdeModulePkg/Bus/Pci/SataControllerDxe/SataControllerDxe.inf
+  MdeModulePkg/Bus/Ata/AtaAtapiPassThru/AtaAtapiPassThru.inf
+  MdeModulePkg/Bus/Ata/AtaBusDxe/AtaBusDxe.inf
+  MdeModulePkg/Bus/Scsi/ScsiBusDxe/ScsiBusDxe.inf
+  MdeModulePkg/Bus/Scsi/ScsiDiskDxe/ScsiDiskDxe.inf
+!endif
+
+  #
+  # SMM
+  #
+!if gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly == FALSE
+  UefiCpuPkg/PiSmmCpuDxeSmm/PiSmmCpuDxeSmm.inf {
+    <LibraryClasses>
+      SmmCpuFeaturesLib|AmdCommonPkg/Library/SmmCpuFeaturesLib/SmmCpuFeaturesLib.inf
+      SmmCpuPlatformHookLib|UefiCpuPkg/Library/SmmCpuPlatformHookLibNull/SmmCpuPlatformHookLibNull.inf
+
+    !if $(LOGGING_ENABLE)
+      DebugLib|MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
+    !else
+      DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf
+    !endif
+
+    !if $(SOURCE_DEBUG_ENABLE)
+      DebugAgentLib|SourceLevelDebugPkg/Library/DebugAgent/SmmDebugAgentLib.inf
+    !endif
+    <PcdsPatchableInModule>
+      #
+      # Disable DEBUG_CACHE because SMI entry/exit may change MTRRs
+      #
+      gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel|0x801000C7
+  }
+
+  MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteDxe.inf
+  MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteSmmDxe.inf
+  MdeModulePkg/Universal/Variable/RuntimeDxe/VariableRuntimeDxe.inf
+!else
+  MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteDxe.inf
+  MdeModulePkg/Universal/Variable/RuntimeDxe/VariableRuntimeDxe.inf
+!endif
+
+  #
+  # ACPI
+  #
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly == FALSE
+    AmdCommonPkg/Acpi/AcpiTables/AcpiPlatform.inf
+    AmdBoardPkg/Acpi/BoardAcpiDxe/BoardAcpiDxe.inf
+    AmdCommonPkg/Acpi/AcpiCommon/AcpiCommon.inf
+    AmdCommonPkg/Acpi/SpcrAcpiDxe/SpcrAcpiDxe.inf {
+      <LibraryClasses>
+        SpcrDeviceLib|AmdCommonPkg/Library/SpcrDeviceLib/SpcrDeviceLib.inf
+  }
+  !endif
+
+!if $(UNIT_TEST_AMD_AML_ENABLE)
+  AmdCommonPkg/Test/UnitTest/Library/AmlLib/AmlUnitTests.inf
+!endif
+
+  #------------------------------------------------------------------------------
+  # Driver to enable BMC VGA device. Obtain the proper GOP driver for the 2600
+  # chip.
+  #
+  # Copy the "uefi_2600.efi" driver:
+  # From (ZIP file): UEFI/x64/
+  # To (workspace):
+  # <workspace>/CrbSupportPkg/BmcGopDxe/X64/
+  #------------------------------------------------------------------------------
+  MdeModulePkg/Universal/Console/GraphicsConsoleDxe/GraphicsConsoleDxe.inf
+  CrbSupportPkg/BmcGopDxe/BmcGopDxe.inf
+
+  #
+  # File System Modules
+  #
+!if gMinPlatformPkgTokenSpaceGuid.PcdPerformanceEnable == TRUE
+  MdeModulePkg/Universal/FvSimpleFileSystemDxe/FvSimpleFileSystemDxe.inf
+!endif
+
+  #
+  # EFI Shell
+  #
+  ShellPkg/Application/Shell/Shell.inf {
+    <LibraryClasses>
+      ShellCommandLib|ShellPkg/Library/UefiShellCommandLib/UefiShellCommandLib.inf
+      NULL|ShellPkg/Library/UefiShellLevel1CommandsLib/UefiShellLevel1CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellLevel2CommandsLib/UefiShellLevel2CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellLevel3CommandsLib/UefiShellLevel3CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellDriver1CommandsLib/UefiShellDriver1CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellDebug1CommandsLib/UefiShellDebug1CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellInstall1CommandsLib/UefiShellInstall1CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellNetwork1CommandsLib/UefiShellNetwork1CommandsLib.inf
+      NULL|ShellPkg/Library/UefiShellAcpiViewCommandLib/UefiShellAcpiViewCommandLib.inf
+      ## NULL|ShellPkg/Library/UefiShellTftpCommandLib/UefiShellTftpCommandLib.inf
+      BcfgCommandLib|ShellPkg/Library/UefiShellBcfgCommandLib/UefiShellBcfgCommandLib.inf
+      FileHandleLib|MdePkg/Library/UefiFileHandleLib/UefiFileHandleLib.inf
+      HandleParsingLib|ShellPkg/Library/UefiHandleParsingLib/UefiHandleParsingLib.inf
+      ShellLib|ShellPkg/Library/UefiShellLib/UefiShellLib.inf
+
+    <PcdsFixedAtBuild>
+      gEfiMdePkgTokenSpaceGuid.PcdDebugPropertyMask|0xFF
+      gEfiShellPkgTokenSpaceGuid.PcdShellLibAutoInitialize|FALSE
+      gEfiMdePkgTokenSpaceGuid.PcdUefiLibMaxPrintBufferSize|16000
+  }
+
+  #
+  # IPMI
+  #
+  AmdCommonPkg/Ipmi/AmdIpmiDxe/AmdIpmiDxe.inf
+  BoardModulePkg/BoardBdsHookDxe/BoardBdsHookDxe.inf
+
+  # LOGO
+  AmdCommonPkg/Logo/LogoDxe/LogoDxe.inf
+
+  # PCI HotPlug
+  !if gEfiMdeModulePkgTokenSpaceGuid.PcdPciBusHotplugDeviceSupport == TRUE
+    AmdCommonPkg/Pci/PciHotPlug/PciHotPlugInit.inf
+  !endif
+
+  # Security
+  !if gMinPlatformPkgTokenSpaceGuid.PcdTpm2Enable == TRUE
+    MinPlatformPkg/Tcg/Tcg2PlatformDxe/Tcg2PlatformDxe.inf {
+      <LibraryClasses>
+        TpmPlatformHierarchyLib|SecurityPkg/Library/PeiDxeTpmPlatformHierarchyLib/PeiDxeTpmPlatformHierarchyLib.inf
+    }
+    UefiCpuPkg/MicrocodeMeasurementDxe/MicrocodeMeasurementDxe.inf
+    MdeModulePkg/Universal/SmbiosMeasurementDxe/SmbiosMeasurementDxe.inf
+  !endif
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdUefiSecureBootEnable == TRUE
+    AmdCommonPkg/SecureBoot/SecureBootDefaultKeysInit/SecureBootDefaultKeysInit.inf
+  !endif
+
+[BuildOptions]
+    GCC:*_*_*_CC_FLAGS     = -D DISABLE_NEW_DEPRECATED_INTERFACES
+    INTEL:*_*_*_CC_FLAGS   = /D DISABLE_NEW_DEPRECATED_INTERFACES
+    MSFT:*_*_*_CC_FLAGS    = /D DISABLE_NEW_DEPRECATED_INTERFACES
+
+  GCC:*_*_*_CC_FLAGS     = -D USE_EDKII_HEADER_FILE
+
+  # Turn off DEBUG messages for Release Builds
+  GCC:RELEASE_*_*_CC_FLAGS     = -D MDEPKG_NDEBUG
+  INTEL:RELEASE_*_*_CC_FLAGS   = /D MDEPKG_NDEBUG
+  MSFT:RELEASE_*_*_CC_FLAGS    = /D MDEPKG_NDEBUG
+
+[BuildOptions.common.EDKII.DXE_RUNTIME_DRIVER, BuildOptions.common.EDKII.DXE_SMM_DRIVER, BuildOptions.common.EDKII.SMM_CORE]
+  #Force modules to 4K alignment
+  MSFT:*_*_*_DLINK_FLAGS = /ALIGN:4096
+  GCC:*_*_*_DLINK_FLAGS = -z common-page-size=0x1000
+
+[BuildOptions.common.EDKII.DXE_DRIVER, BuildOptions.common.EDKII.DXE_CORE, BuildOptions.common.EDKII.UEFI_DRIVER]
+  #Force modules to 4K alignment
+  MSFT:*_*_*_DLINK_FLAGS = /ALIGN:4096
+  GCC:*_*_*_DLINK_FLAGS = -z common-page-size=0x1000
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/Project.fdf b/GenoaOpenBoardPkg/S8050BoardPkg/Project.fdf
new file mode 100644
index 0000000..ba657ab
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/Project.fdf
@@ -0,0 +1,821 @@
+#;*****************************************************************************
+#; Copyright (C) 2019-2024 Advanced Micro Devices, Inc. All rights reserved.
+#;
+#;*****************************************************************************
+
+
+##############################################################################
+#
+# GenoaOnyx reference board - 2 SPI FLash devices accessible by x86 (selected by DIP-switch):
+# 1) 32MB Flash with 10-pin header next to the VGA connector.
+# 2) 64MB Flash with 10-pin header at 90-degrees from VGA connector, and also accessible by the BMC.
+#
+##############################################################################
+
+[Defines]
+  !include $(PLATFORM_NAME)/Include/Fdf/FlashMapInclude.fdf
+
+  #-----------------------------------------------------------
+#  End of [Defines] section
+#-----------------------------------------------------------
+
+[FD.Platform]
+  # Need ROM 2 flash base for calculated Addresses of FVs below 4GB
+  BaseAddress   = $(ROM2_FLASH_BASE)|gMinPlatformPkgTokenSpaceGuid.PcdFlashAreaBaseAddress
+  # Need full flash size for FD Image size
+  Size          = $(ROM3_FLASH_SIZE)
+  ErasePolarity = 1
+  BlockSize     = $(SPI_BLOCK_SIZE)
+  NumBlocks     = $(SPI_NUM_BLOCKS)
+  SET gMinPlatformPkgTokenSpaceGuid.PcdFlashAreaSize = $(ROM2_FLASH_SIZE)
+  SET gAmdCommonPkgTokenSpaceGuid.PcdRom3FlashAreaBase = $(ROM3_FLASH_BASE)
+  SET gAmdCommonPkgTokenSpaceGuid.PcdRom3FlashAreaSize = $(ROM3_FLASH_SIZE)
+
+  #
+  # Embedded Firmware Signature
+  #
+  $(FV_FW_SIG_OFFSET)|$(FV_FW_SIG_SIZE)
+    DATA = {
+      0xAA, 0x55, 0xAA, 0x55,     # 0x00: Signature
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x10, 0x02, 0xFF,     # 0x0C: XHC ROM Addr
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x60, 0x14, 0x00,     # 0x14: PSP Dir1
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0x00,     #
+      0xFE, 0xFF, 0xFF, 0xFF,     # 0x24: bit[0]=0: Second generation EFS Genoa A0, bit[1]=0: Multi Gen EFS for Genoa B0
+      0x00, 0x60, 0x34, 0x00,     # 0x28: BIOS Dir1
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0x00,     #
+      0x00, 0x00, 0x00, 0xFF,     # 0x4F: Reserved
+      0x0E, 0xFF, 0xFF, 0xFF      # 0x50: eSPI0 Configuration
+                                  #       Default value = 0x0E (eSPI0, bus1, Alert mode, Port 80h, CLK1)
+                                  #
+                                  #       bit[0]:   eSPI PSP configuration valid bit.
+                                  #                 0-Valid, 1-Not Valid
+                                  #       bit[1]:   enable 80h port.
+                                  #                 0-disable, 1-enable
+                                  #       bit[2]:   Alert mode.
+                                  #                 0-non-Alert, 1-dedicated Alert Pin.
+                                  #       bit[3]:   Data Bus,
+                                  #                 0-bus0, 1-bus1.
+                                  #       bit[4]:   Clock pin. ignore for controller0 (always CLK0).
+                                  #                 for controller1, 0-CLK1, 1-CLK2
+                                  #       bit[7:5]: reserved
+                                  # 0x51: eSPI1 Configuration
+                                  #       bit[0]:   eSPI PSP configuration valid bit.
+                                  #                 0-Valid, 1-Not Valid
+                                  #       bit[1]:   enable 80h port.
+                                  #                 0-disable, 1-enable
+                                  #       bit[2]:   Alert mode.
+                                  #                 0-non-Alert, 1-dedicated Alert Pin.
+                                  #       bit[3]:   Data Bus,
+                                  #                 0-bus0, 1-bus1.
+                                  #       bit[4]:   Clock pin. ignore for controller0 (always CLK0).
+                                  #                 for controller1, 0-CLK1, 1-CLK2
+                                  #       bit[7:5]: reserved
+    }
+
+  #
+  # PSP NVRAM: NV Storage Area
+  # NV_VARIABLE_STORE
+  #
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashNvStorageVariableOffset|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableBase|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize
+  DATA = {
+    ## This is the EFI_FIRMWARE_VOLUME_HEADER
+    # ZeroVector []
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    # FileSystemGuid: gEfiSystemNvDataFvGuid =
+    #   { 0xFFF12B8D, 0x7696, 0x4C8B,
+    #     { 0xA9, 0x85, 0x27, 0x47, 0x07, 0x5B, 0x4F, 0x50 }}
+    0x8D, 0x2B, 0xF1, 0xFF, 0x96, 0x76, 0x8B, 0x4C,
+    0xA9, 0x85, 0x27, 0x47, 0x07, 0x5B, 0x4F, 0x50,
+    # FvLength: 0x20000
+    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
+    # Signature "_FVH"       # Attributes
+    0x5f, 0x46, 0x56, 0x48, 0xff, 0xfe, 0x04, 0x00,
+    # HeaderLength # CheckSum # ExtHeaderOffset #Reserved #Revision
+    0x48, 0x00, 0x19, 0xF9, 0x00, 0x00, 0x00, 0x02,
+    # Blockmap[0]: 32 Blocks * 0x1000 Bytes / Block
+    0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
+    # Blockmap[1]: End (null-terminated)
+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+    ## This is the VARIABLE_STORE_HEADER
+    !if gMinPlatformPkgTokenSpaceGuid.PcdUefiSecureBootEnable == TRUE
+      # Signature: gEfiAuthenticatedVariableGuid =
+      #   { 0xaaf32c78, 0x947b, 0x439a,
+      #     { 0xa1, 0x80, 0x2e, 0x14, 0x4e, 0xc3, 0x77, 0x92 }}
+      0x78, 0x2c, 0xf3, 0xaa, 0x7b, 0x94, 0x9a, 0x43,
+      0xa1, 0x80, 0x2e, 0x14, 0x4e, 0xc3, 0x77, 0x92,
+    !else
+      #  Signature: gEfiVariableGuid =
+      #    { 0xddcf3616, 0x3275, 0x4164,
+      #      { 0x98, 0xb6, 0xfe, 0x85, 0x70, 0x7f, 0xfe, 0x7d }}
+      0x16, 0x36, 0xcf, 0xdd, 0x75, 0x32, 0x64, 0x41,
+      0x98, 0xb6, 0xfe, 0x85, 0x70, 0x7f, 0xfe, 0x7d,
+    !endif
+    # Size: 0x0E000 (gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageVariableSize) -
+    #          0x48 (size of EFI_FIRMWARE_VOLUME_HEADER) = 0x0DFB8
+    # This can speed up the Variable Dispatch a bit.
+    0xB8, 0xDF, 0x00, 0x00,
+    # FORMATTED: 0x5A #HEALTHY: 0xFE #Reserved: UINT16 #Reserved1: UINT32
+    0x5A, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+  }
+
+  #
+  # NV_FTW_WORKING
+  #
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingOffset|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingBase|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwWorkingSize
+  DATA = {
+    # EFI_FAULT_TOLERANT_WORKING_BLOCK_HEADER->Signature = gEdkiiWorkingBlockSignatureGuid =
+    #  { 0x9e58292b, 0x7c68, 0x497d,
+    #    { 0xa0, 0xce, 0x65,  0x0, 0xfd, 0x9f, 0x1b, 0x95 }}
+    0x2b, 0x29, 0x58, 0x9e, 0x68, 0x7c, 0x7d, 0x49,
+    0xa0, 0xce, 0x65,  0x0, 0xfd, 0x9f, 0x1b, 0x95,
+    # Crc:UINT32            #WorkingBlockValid:1, WorkingBlockInvalid:1, Reserved
+    0xE2, 0x33, 0xF2, 0x03, 0xFE, 0xFF, 0xFF, 0xFF,
+    # WriteQueueSize: UINT64 #Size: 0x2000 - 0x20 (FTW_WORKING_HEADER) = 0x1FE0
+    0xE0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+  }
+
+  #
+  # NV_FTW_SPARE
+  #
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareOffset|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareSize
+  gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareBase|gEfiMdeModulePkgTokenSpaceGuid.PcdFlashNvStorageFtwSpareSize
+
+  # Advance firmware volume where advance Board features are enabled, like IPMI etc
+  !if $(ROM3_FLASH_ENABLE) == FALSE
+    gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedOffset|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedSize
+    gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedBase|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedSize
+    FV = FvAdvanced
+
+    gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecurityOffset|gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecuritySize
+    gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecurityBase|gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecuritySize
+    FV = FvAdvancedSecurity
+
+    gMinPlatformPkgTokenSpaceGuid.PcdFlashFvOsBootOffset|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvOsBootSize
+    gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvOsBootBase|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvOsBootSize
+    FV = FvOsBoot
+
+    gMinPlatformPkgTokenSpaceGuid.PcdFlashFvUefiBootOffset|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvUefiBootSize
+    gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvUefiBootBase|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvUefiBootSize
+    FV = FvUefiBoot
+  !endif
+
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashFvSecurityOffset|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvSecuritySize
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashFvSecurityBase|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvSecuritySize
+  FV = FvSecurity
+
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPostMemoryOffset|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPostMemorySize
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPostMemoryBase|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPostMemorySize
+  FV = FvPostMemory
+
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedPreMemoryOffset|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedPreMemorySize
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedPreMemoryBase|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedPreMemorySize
+  FV = FvAdvancedPreMemory
+
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPreMemoryOffset|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPreMemorySize
+  gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPreMemoryBase|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvPreMemorySize
+  FV = FvPreMemory
+
+  !if $(ROM3_FLASH_ENABLE) == TRUE
+    gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedOffset|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvAdvancedSize
+    FV = FvAdvanced
+
+    gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecurityOffset|gAmdCommonPkgTokenSpaceGuid.PcdAmdFlashFvAdvancedSecuritySize
+    FV = FvAdvancedSecurity
+
+    gMinPlatformPkgTokenSpaceGuid.PcdFlashFvOsBootOffset|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvOsBootSize
+    FV = FvOsBoot
+
+    gMinPlatformPkgTokenSpaceGuid.PcdFlashFvUefiBootOffset|gMinPlatformPkgTokenSpaceGuid.PcdFlashFvUefiBootSize
+    FV = FvUefiBoot
+
+    # Fill unused space to create 32 MB FD image
+    $(ROM3_FLASH_SIZE) - 0x1000|0x1000
+  !else
+    # Fill unused space to create 32 MB FD image
+    0x01000000|0x01000000
+  !endif
+
+[FV.FvPreMemory]
+  FvNameGuid          = 1BD2AB8A-BD04-4ee1-83B0-B05E5500121D
+  FvBaseAddress       = $(BOOT_FV_BASE)
+  FvForceRebase       = TRUE
+  BlockSize           = $(SPI_BLOCK_SIZE)
+  FvAlignment         = 64
+  ERASE_POLARITY      = 1
+  MEMORY_MAPPED       = TRUE
+  STICKY_WRITE        = TRUE
+  LOCK_CAP            = TRUE
+  LOCK_STATUS         = TRUE
+  WRITE_DISABLED_CAP  = TRUE
+  WRITE_ENABLED_CAP   = TRUE
+  WRITE_STATUS        = TRUE
+  WRITE_LOCK_CAP      = TRUE
+  WRITE_LOCK_STATUS   = TRUE
+  READ_DISABLED_CAP   = TRUE
+  READ_ENABLED_CAP    = TRUE
+  READ_STATUS         = TRUE
+  READ_LOCK_CAP       = TRUE
+  READ_LOCK_STATUS    = TRUE
+
+  APRIORI PEI {
+    INF  MdeModulePkg/Universal/PCD/Pei/Pcd.inf
+    INF  edk2/MdeModulePkg/Universal/PcatSingleSegmentPciCfg2Pei/PcatSingleSegmentPciCfg2Pei.inf
+    #INF  AgesaPkg/Addendum/PciSegments/PciExpressPciCfg2/PciExpressPciCfg2.inf
+    INF  MdeModulePkg/Universal/ReportStatusCodeRouter/Pei/ReportStatusCodeRouterPei.inf
+    INF  UefiCpuPkg/CpuIoPei/CpuIoPei.inf
+    INF  MdeModulePkg/Universal/Variable/Pei/VariablePei.inf
+    INF  MinPlatformPkg/PlatformInit/PlatformInitPei/PlatformInitPreMem.inf
+    INF  MdeModulePkg/Universal/StatusCodeHandler/Pei/StatusCodeHandlerPei.inf
+    INF AmdOpenSilPkg/opensil-uefi-interface/Platform/$(SIL_PLATFORM_NAME)-$(SOC_SKU)/Pei/Sil$(SIL_PLATFORM_NAME)Pei.inf
+  }
+
+  # SEC Core
+  INF  UefiCpuPkg/SecCore/SecCore.inf
+
+  # PEI Core
+  INF  MdeModulePkg/Core/Pei/PeiMain.inf
+
+  !include MinPlatformPkg/Include/Fdf/CorePreMemoryInclude.fdf
+  INF  AgesaPkg/Addendum/PciSegments/PciExpressPciCfg2/PciExpressPciCfg2.inf
+
+  # PEIM
+  INF MinPlatformPkg/PlatformInit/ReportFv/ReportFvPei.inf
+  INF MinPlatformPkg/PlatformInit/PlatformInitPei/PlatformInitPreMem.inf
+  # INF $(PLATFORM_BOARD_PACKAGE)/BiosInfo/BiosInfo.inf
+  # INF MdeModulePkg/Universal/ResetSystemPei/ResetSystemPei.inf
+  INF MdeModulePkg/Universal/CapsulePei/CapsulePei.inf
+
+  INF AmdOpenSilPkg/opensil-uefi-interface/Platform/$(SIL_PLATFORM_NAME)-$(SOC_SKU)/Pei/Sil$(SIL_PLATFORM_NAME)Pei.inf
+
+  INF AgesaModulePkg/Mem/AmdMemoryHobInfoPeimGenoa/AmdMemoryHobInfoPeimGenoa.inf
+
+[FV.FvAdvancedPreMemory]
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 87F76F65-4128-4B77-85D8-DE0F757B40F8
+
+  # !include AdvancedFeaturePkg/Include/PreMemory.fdf
+  # IPMI
+  INF AmdCommonPkg/Ipmi/AmdIpmiPei/AmdIpmiPei.inf
+
+[FV.FvPostMemoryUncompact]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 09F55EB9-7181-4919-8755-9185E3E35CA9
+
+  !include MinPlatformPkg/Include/Fdf/CorePostMemoryInclude.fdf
+
+  # Init Board Config PCD
+  INF MinPlatformPkg/PlatformInit/PlatformInitPei/PlatformInitPostMem.inf
+
+[FV.FvPostMemory]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 3445B977-C771-4928-9851-2EFBD55CAACD
+
+  FILE FV_IMAGE = F38D7A3E-35F1-4CE4-ACC8-AA059ABEA622{
+    SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
+      SECTION FV_IMAGE = FvPostMemoryUncompact
+    }
+  }
+  !if $(ROM3_FLASH_ENABLE) == TRUE
+    FILE FV_IMAGE = 8DA879CE-D6D0-4687-8025-0EA967F506BD {
+      SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
+        SECTION FV_IMAGE = FvDxeMain
+      }
+    }
+  !endif
+
+[FV.FvUefiBootUncompact]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = E889A6E3-385B-4DAF-A19A-E9B1D41EB046
+
+  APRIORI DXE {
+    INF  MdeModulePkg/Universal/PCD/Dxe/Pcd.inf
+    INF  MdeModulePkg/Universal/ReportStatusCodeRouter/RuntimeDxe/ReportStatusCodeRouterRuntimeDxe.inf
+    INF  MdeModulePkg/Universal/StatusCodeHandler/RuntimeDxe/StatusCodeHandlerRuntimeDxe.inf
+  }
+  !include MinPlatformPkg/Include/Fdf/CoreUefiBootInclude.fdf
+
+  # AMD AGCL DXE Includes
+  #
+  #!include $(AGESA_DXE_INC_FDF)
+
+  # EDK Core modules
+  INF  UefiCpuPkg/CpuDxe/CpuDxe.inf
+  INF  MdeModulePkg/Universal/SectionExtractionDxe/SectionExtractionDxe.inf
+  !if $(SOURCE_DEBUG_ENABLE)
+    INF  SourceLevelDebugPkg/DebugAgentDxe/DebugAgentDxe.inf
+  !endif
+
+  # File System Modules
+  !if gMinPlatformPkgTokenSpaceGuid.PcdPerformanceEnable == TRUE
+    INF  MdeModulePkg/Universal/FvSimpleFileSystemDxe/FvSimpleFileSystemDxe.inf
+  !endif
+
+  # Console
+  INF CrbSupportPkg/BmcGopDxe/BmcGopDxe.inf
+
+  # UEFI Shell
+  !if $(SHELL_BIN_PACKAGE)
+    INF  ShellBinPkg/UefiShell/UefiShell.inf
+  !else
+    INF  ShellPkg/Application/Shell/Shell.inf
+  !endif
+
+  # AmdHiiConfigRouting
+  INF AmdCommonPkg/Hii/HiiConfigRouting/AmdConfigRouting.inf
+
+  # PCI
+  INF  MdeModulePkg/Bus/Pci/PciHostBridgeDxe/PciHostBridgeDxe.inf
+
+  # SATA
+  !if $(SATA_SUPPORT)
+    INF  MdeModulePkg/Bus/Pci/SataControllerDxe/SataControllerDxe.inf
+    INF  MdeModulePkg/Bus/Ata/AtaAtapiPassThru/AtaAtapiPassThru.inf
+    INF  MdeModulePkg/Bus/Ata/AtaBusDxe/AtaBusDxe.inf
+    INF  MdeModulePkg/Bus/Scsi/ScsiBusDxe/ScsiBusDxe.inf
+    INF  MdeModulePkg/Bus/Scsi/ScsiDiskDxe/ScsiDiskDxe.inf
+  !endif
+
+  # OPENSIL
+  # OPENSIL_OVERRIDE STARTS
+  INF AmdOpenSilPkg/opensil-uefi-interface/Platform/$(SIL_PLATFORM_NAME)-$(SOC_SKU)/Dxe/Sil$(SIL_PLATFORM_NAME)Dxe.inf
+  # OPENSIL_OVERRIDE ENDS
+
+  # NVME
+  INF  MdeModulePkg/Bus/Pci/NvmExpressDxe/NvmExpressDxe.inf
+
+  # USB
+  !if $(USB_SUPPORT)
+    INF  MdeModulePkg/Bus/Usb/UsbMouseDxe/UsbMouseDxe.inf
+  !endif
+
+  # SMBIOS
+  !include $(PLATFORM_NAME)/Include/Fdf/Smbios.fdf
+
+  # AMd AML
+  !if $(UNIT_TEST_AMD_AML_ENABLE)
+    INF AmdCommonPkg/Test/UnitTest/Library/AmlLib/AmlUnitTests.inf
+  !endif
+
+  # Board
+  INF  BoardModulePkg/BoardBdsHookDxe/BoardBdsHookDxe.inf
+  INF  MinPlatformPkg/PlatformInit/PlatformInitDxe/PlatformInitDxe.inf
+  # INF  $(PLATFORM_PACKAGE)/Test/TestPointStubDxe/TestPointStubDxe.inf
+
+  # Spi Flash Drivers
+  INF  AmdCommonPkg/Spi/BoardSpiConfig/BoardSpiConfigDxe.inf
+  INF  AmdCommonPkg/Spi/BoardSpiBus/BoardSpiBusDxe.inf
+  INF  AmdCommonPkg/Spi/AmdSpiHc/AmdSpiHcDxe.inf
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly == FALSE
+    INF  AmdCommonPkg/Spi/BoardSpiConfig/BoardSpiConfigSmm.inf
+    INF  AmdCommonPkg/Spi/BoardSpiBus/BoardSpiBusSmm.inf
+    INF  AmdCommonPkg/Spi/AmdSpiHc/AmdSpiHcSmm.inf
+    INF  AmdCommonPkg/Spi/AmdSpiFvb/AmdSpiFvbSmm.inf
+    INF  AmdCommonPkg/Spi/SpiNorFlashJedec/SpiNorFlashSmm.inf
+  !else
+    INF AmdCommonPkg/Spi/SpiNorFlashJedec/SpiNorFlashDxe.inf
+    INF AmdCommonPkg/Spi/AmdSpiFvb/AmdSpiFvbDxe.inf
+  !endif
+
+[FV.FvUefiBoot]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 5489442E-30C6-479F-9CA4-BAAAEE279A20
+
+  FILE FV_IMAGE = B5733BA8-C486-4B0F-889C-0815F483450A {
+    SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
+      SECTION FV_IMAGE = FvUefiBootUncompact
+    }
+  }
+
+[FV.FvOsBootUncompact]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 48FD70BC-3389-4B90-A364-EF829F41DB70
+
+  !include MinPlatformPkg/Include/Fdf/CoreOsBootInclude.fdf
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly == FALSE
+    INF  UefiCpuPkg/PiSmmCpuDxeSmm/PiSmmCpuDxeSmm.inf
+    INF  MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteSmmDxe.inf
+  !else
+    INF  MdeModulePkg/Universal/FaultTolerantWriteDxe/FaultTolerantWriteDxe.inf
+  !endif
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly == FALSE
+    INF AmdCommonPkg/Acpi/AcpiTables/AcpiPlatform.inf
+    INF RuleOverride = DRIVER_ACPITABLE   AmdBoardPkg/Acpi/BoardAcpiDxe/BoardAcpiDxe.inf
+    INF AmdCommonPkg/Acpi/AcpiCommon/AcpiCommon.inf
+    INF AmdCommonPkg/Acpi/SpcrAcpiDxe/SpcrAcpiDxe.inf
+  !endif
+
+[FV.FvLateSilicon]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = C3740903-41CC-4C7E-B9A1-7A4B59C0CEC2
+
+[FV.FvOsBoot]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 7E097F4E-A40F-47D4-93FB-8802BB9051C0
+
+  FILE FV_IMAGE = B975908C-6ECF-4413-A87A-199DDA11AB37 {
+    SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
+      SECTION FV_IMAGE = FvOsBootUncompact
+    }
+  }
+  FILE FV_IMAGE = 41077C2D-331A-4188-809A-E5278A534E51 {
+    SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
+      SECTION FV_IMAGE = FvLateSilicon
+    }
+  }
+
+[FV.FvSecurityPreMemory]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 87E97057-5DEF-4EB3-ACC5-063AC68AA7B7
+
+  !include MinPlatformPkg/Include/Fdf/CoreSecurityPreMemoryInclude.fdf
+
+[FV.FvSecurityPostMemory]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = FBA1BC9C-66FD-4B05-887C-C00AB6DDEE1F
+
+  !include MinPlatformPkg/Include/Fdf/CoreSecurityPostMemoryInclude.fdf
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdTpm2Enable == TRUE
+    INF MinPlatformPkg/Tcg/Tcg2PlatformPei/Tcg2PlatformPei.inf
+  !endif
+
+[FV.FvSecurityLate]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 79045073-CB0E-4E28-BC31-4AE00FBF4907
+
+  !include MinPlatformPkg/Include/Fdf/CoreSecurityLateInclude.fdf
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdBootToShellOnly == FALSE
+    !if gMinPlatformPkgTokenSpaceGuid.PcdTpm2Enable == TRUE
+      INF MinPlatformPkg/Tcg/Tcg2PlatformDxe/Tcg2PlatformDxe.inf
+      INF UefiCpuPkg/MicrocodeMeasurementDxe/MicrocodeMeasurementDxe.inf
+      INF MdeModulePkg/Universal/SmbiosMeasurementDxe/SmbiosMeasurementDxe.inf
+    !endif
+  !endif
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdUefiSecureBootEnable == TRUE
+    INF AmdCommonPkg/SecureBoot/SecureBootDefaultKeysInit/SecureBootDefaultKeysInit.inf
+
+    FILE FREEFORM = 85254ea7-4759-4fc4-82d4-5eed5fb0a4a0 {
+      SECTION RAW = Platform/SecurebootKeys/PK/PK.cer
+    }
+
+    FILE FREEFORM = 6f64916e-9f7a-4c35-b952-cd041efb05a3 {
+      SECTION RAW = Platform/SecurebootKeys/KEK/MicCorKEKCA2011_2011-06-24.crt
+    }
+
+    FILE FREEFORM = c491d352-7623-4843-accc-2791a7574421 {
+      SECTION RAW = Platform/SecurebootKeys/db/MicWinProPCA2011_2011-10-19.crt
+      SECTION RAW = Platform/SecurebootKeys/db/MicCorUEFCA2011_2011-06-27.crt
+    }
+
+    FILE FREEFORM = 5740766a-718e-4dc0-9935-c36f7d3f884f {
+      SECTION RAW = Platform/SecurebootKeys/dbx/dbxupdate_x64.bin
+    }
+
+  !endif
+
+[FV.FvSecurity]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 2D25F4E7-50AB-442C-B2AE-9C48F3116E62
+
+  !if gMinPlatformPkgTokenSpaceGuid.PcdTpm2Enable == TRUE
+    FILE FV_IMAGE = 757CC075-1428-423D-A73C-22639706C119 {
+         SECTION FV_IMAGE = FvSecurityPreMemory
+      }
+  !endif
+
+  FILE FV_IMAGE = 7E21EF3C-D813-40C0-BE9E-A5F739CA88AC {
+    SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
+      SECTION FV_IMAGE = FvSecurityPostMemory
+    }
+  }
+
+[FV.FvAdvancedSecurity]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 2FFD72AF-4917-4430-8A46-97BD74816264
+
+  FILE FV_IMAGE = B431E18D-A610-4A65-8D81-A4E482354EF8 {
+    SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
+      SECTION FV_IMAGE = FvSecurityLate
+    }
+  }
+
+[FV.FvAdvancedUncompact]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = 9DC9F824-7D1E-4A81-A410-CE3CA6ABA779
+
+  # IPMI Driver
+  INF AmdCommonPkg/Ipmi/AmdIpmiDxe/AmdIpmiDxe.inf
+  #
+  # Network Advanced Features
+  #
+  !if gNetworkFeaturePkgTokenSpaceGuid.PcdNetworkFeatureEnable == TRUE
+    !include Network/NetworkFeaturePkg/Include/PostMemory.fdf
+  !endif
+
+  # LOGO
+  INF AmdCommonPkg/Logo/LogoDxe/LogoDxe.inf
+
+  # PCI HotPlug
+  !if gEfiMdeModulePkgTokenSpaceGuid.PcdPciBusHotplugDeviceSupport == TRUE
+    INF AmdCommonPkg/Pci/PciHotPlug/PciHotPlugInit.inf
+  !endif
+
+[FV.FvAdvanced]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = FC5D42FA-964F-47D5-9D53-35D997F1B83E
+
+  FILE FV_IMAGE = 9E21FD93-9C72-4c15-8C4B-E77F1DB2D792 {
+    SECTION GUIDED EE4E5898-3914-4259-9D6E-DC7BD79403CF PROCESSING_REQUIRED = TRUE {
+      SECTION FV_IMAGE = FvAdvancedUncompact
+    }
+  }
+
+[FV.FvDxeMain]
+  BlockSize          = $(SPI_BLOCK_SIZE)
+  FvAlignment        = 64
+  ERASE_POLARITY     = 1
+  MEMORY_MAPPED      = TRUE
+  STICKY_WRITE       = TRUE
+  LOCK_CAP           = TRUE
+  LOCK_STATUS        = TRUE
+  WRITE_DISABLED_CAP = TRUE
+  WRITE_ENABLED_CAP  = TRUE
+  WRITE_STATUS       = TRUE
+  WRITE_LOCK_CAP     = TRUE
+  WRITE_LOCK_STATUS  = TRUE
+  READ_DISABLED_CAP  = TRUE
+  READ_ENABLED_CAP   = TRUE
+  READ_STATUS        = TRUE
+  READ_LOCK_CAP      = TRUE
+  READ_LOCK_STATUS   = TRUE
+  FvNameGuid         = AF85B2E1-DC13-445A-AF0F-C7659E39BBAC
+
+  INF MdeModulePkg/Core/Dxe/DxeMain.inf
+
+################################################################################
+#
+# Rules are use with the [FV] section's module INF type to define
+# how an FFS file is created for a given INF file. The following Rule are the default
+# rules for the different module type. User can add the customized rules to define the
+# content of the FFS file.
+#
+################################################################################
+!include MinPlatformPkg/Include/Fdf/RuleInclude.fdf
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/PspDataGenoa.xml b/GenoaOpenBoardPkg/S8050BoardPkg/PspDataGenoa.xml
new file mode 100644
index 0000000..b1ffcf8
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/PspDataGenoa.xml
@@ -0,0 +1,101 @@
+<?xml version="1.0" ?>
+<!--
+/*****************************************************************************
+ * Copyright (C) 2019-2024 Advanced Micro Devices, Inc. All rights reserved.
+ *
+ *******************************************************************************/
+-->
+<DIRS AddressMode = "1">
+  <PSP_DIR Level="1" Base="0x146000" Size="0x200000" SpiBlockSize="0x1000">
+    <IMAGE_ENTRY Type="0x0" File="AmdPubKey.tkn"/>
+    <POINT_ENTRY Type="0x1" Address="0x387400" Size="0x34000"/>
+    <IMAGE_ENTRY Type="0x3" File="TypeId0x03_PspRecBl.esbin"/>
+    <IMAGE_ENTRY Type="0x8" SubProgram="0x1" File="TypeId0x08_SmuFirmware.ecsbin"/>
+    <IMAGE_ENTRY Type="0xA" File="TypeId0x0A_PspAblPubKey.stkn"/>
+    <VALUE_ENTRY Type="0xB" Value="0x01"/>
+    <IMAGE_ENTRY Type="0x12" SubProgram="0x1" File="TypeId0x12_SmuFirmware2.sbin"/>
+    <IMAGE_ENTRY Type="0x13" File="TypeId0x13_SduFw.esbin"/>
+    <IMAGE_ENTRY Type="0x21" File="TypeId0x21_PspAmdIkek.bin"/>
+    <IMAGE_ENTRY Type="0x22" File="SecureEmptyToken.bin"/>
+    <IMAGE_ENTRY Type="0x24" SubProgram="0x1" File="TypeId0x24_RegisterAccessPolicy.esbin"/>
+    <IMAGE_ENTRY Type="0x2a" SubProgram="0x1" File="TypeId0x2a_Mp5.ecsbin"/>
+    <IMAGE_ENTRY Type="0x30" File="Typex30_0_0_0_PspAgesaBL0.bin"/>
+    <POINT_ENTRY Type="0x40" Address="0x387000" Size="0x400"/>
+    <IMAGE_ENTRY Type="0x42" File="TypeId0x42_PhyFw.esbin"/>
+    <IMAGE_ENTRY Type="0x44" File="TypeId0x44_USB_PHY.esbin"/>
+    <IMAGE_ENTRY Type="0x47" File="TypeId0x47_PspDrtmUapp.esbin"/>
+    <IMAGE_ENTRY Type="0x50" File="TypeId0x50_PspKeyDataBase.sbin"/>
+    <IMAGE_ENTRY Type="0x55" File="TypeId0x55_SPLTable.sbin"/>
+    <IMAGE_ENTRY Type="0x5D" File="TypeId0x5DMpioFw.cesbin"/>
+    <IMAGE_ENTRY Type="0x76" File="TypeId0x76_DfRib.ecsbin"/>
+    <IMAGE_ENTRY Type="0x8C" File="TypeId0x8C_MPDMATF.esbin"/>
+    <IMAGE_ENTRY Type="0x91" File="TypeId0x91_GmiPhyFw.esbin"/>
+    <IMAGE_ENTRY Type="0x92" File="TypeId0x92_Page.esbin"/>
+  </PSP_DIR>
+  <BIOS_DIR Level="1" Base="0x346000" Size="0x40000" SpiBlockSize=" 0x1000">
+    <IMAGE_ENTRY Type="0x68" Instance="0x00" SubProgram="0x0" File="BiosDirL10_Typex68_0_0_0_ApcbRec.bin"/>
+    <IMAGE_ENTRY Type="0x68" Instance="0x08" SubProgram="0x0" File="BiosDirL10_Typex68_0_8_0_ApcbRec.bin"/>
+    <IMAGE_ENTRY Type="0x68" Instance="0x09" SubProgram="0x0" File="BiosDirL10_Typex68_0_9_0_ApcbRec.bin"/>
+    <POINT_ENTRY Type="0x61" Address="0x0" Size="0x0" Destination="0x4000000"/>
+    <POINT_ENTRY Type="0x62" Address="0xD00000" Destination="0x76D00000" Size="0x300000">
+     <TypeAttrib Compressed="0x0" Copy="0x1" ReadOnly="0x0" RegionType="0x0" ResetImage="0x1"/>
+    </POINT_ENTRY>
+    <IMAGE_ENTRY Type="0x64" Instance="0x03" SubProgram="0x0" File="Appb_Ddr5_0x64_3_Rdimm_Imem1.ecsbin"/>
+    <IMAGE_ENTRY Type="0x65" Instance="0x03" SubProgram="0x0" File="Appb_Ddr5_0x65_3_Rdimm_Dmem1.ecsbin"/>
+    <IMAGE_ENTRY Type="0x64" Instance="0x04" SubProgram="0x0" File="Appb_Ddr5_0x64_4_Rdimm_Imem2.ecsbin"/>
+    <IMAGE_ENTRY Type="0x65" Instance="0x04" SubProgram="0x0" File="Appb_Ddr5_0x65_4_Rdimm_Dmem2.ecsbin"/>
+    <IMAGE_ENTRY Type="0x64" Instance="0x09" SubProgram="0x0" File="Appb_Ddr5_0x64_9_Rdimm_Imem1.ecsbin"/>
+    <IMAGE_ENTRY Type="0x65" Instance="0x09" SubProgram="0x0" File="Appb_Ddr5_0x65_9_Rdimm_Dmem1.ecsbin"/>
+    <IMAGE_ENTRY Type="0x64" Instance="0x0A" SubProgram="0x0" File="Appb_Ddr5_0x64_A_Rdimm_Imem2.ecsbin"/>
+    <IMAGE_ENTRY Type="0x65" Instance="0x0A" SubProgram="0x0" File="Appb_Ddr5_0x65_A_Rdimm_Dmem2.ecsbin"/>
+    <POINT_ENTRY Type="0x70" Address="0x5BB000" Size="0x400"/>
+  </BIOS_DIR>
+  <PSP_DIR Level="2" Base="0x387000" Size="0x234000" SpiBlockSize="0x1000">
+    <IMAGE_ENTRY Type="0x1" File="TypeId0x01_PspBl.esbin" Size="0x34000"/>
+    <IMAGE_ENTRY Type="0x8" SubProgram="0x1" File="TypeId0x08_SmuFirmware.ecsbin"/>
+    <IMAGE_ENTRY Type="0x9" File="TypeId0x09_PspDebugUnlockToken.stkn"/>
+    <IMAGE_ENTRY Type="0xA" File="TypeId0x0A_PspAblPubKey.stkn"/>
+    <VALUE_ENTRY Type="0xB" Value="0x01"/>
+    <IMAGE_ENTRY Type="0x12" SubProgram="0x1" File="TypeId0x12_SmuFirmware2.sbin"/>
+    <IMAGE_ENTRY Type="0x13" File="TypeId0x13_SduFw.esbin"/>
+    <IMAGE_ENTRY Type="0x21" File="TypeId0x21_PspAmdIkek.bin"/>
+    <IMAGE_ENTRY Type="0x22" File="SecureEmptyToken.bin"/>
+    <IMAGE_ENTRY Type="0x24" SubProgram="0x1" File="TypeId0x24_RegisterAccessPolicy.esbin"/>
+    <IMAGE_ENTRY Type="0x2a" SubProgram="0x1" File="TypeId0x2a_Mp5.ecsbin"/>
+    <IMAGE_ENTRY Type="0x30" File="Typex30_0_0_0_PspAgesaBL0.bin"/>
+    <IMAGE_ENTRY Type="0x38" File="PspSevEmptyData.bin"/>
+    <IMAGE_ENTRY Type="0x39" File="TypeId0x39_SevFw.esbin"/>
+    <IMAGE_ENTRY Type="0x42" File="TypeId0x42_PhyFw.esbin"/>
+    <IMAGE_ENTRY Type="0x44" File="TypeId0x44_USB_PHY.esbin"/>
+    <IMAGE_ENTRY Type="0x47" File="TypeId0x47_PspDrtmUapp.esbin"/>
+    <IMAGE_ENTRY Type="0x50" File="TypeId0x50_PspKeyDataBase.sbin"/>
+    <IMAGE_ENTRY Type="0x55" File="TypeId0x55_SPLTable.sbin"/>
+    <IMAGE_ENTRY Type="0x5D" File="TypeId0x5DMpioFw.cesbin"/>
+    <IMAGE_ENTRY Type="0x76" File="TypeId0x76_DfRib.ecsbin"/>
+    <IMAGE_ENTRY Type="0x8C" File="TypeId0x8C_MPDMATF.esbin"/>
+    <IMAGE_ENTRY Type="0x91" File="TypeId0x91_GmiPhyFw.esbin"/>
+    <IMAGE_ENTRY Type="0x92" File="TypeId0x92_Page.esbin"/>
+  </PSP_DIR>
+  <BIOS_DIR Level="2" Base="0x5BB000" Size="0xC0000" SpiBlockSize=" 0x1000">
+    <IMAGE_ENTRY Type="0x68" Instance="0x00" SubProgram="0x0" File="BiosDirL20_Typex68_0_0_0_ApcbRec.bin"/>
+    <IMAGE_ENTRY Type="0x68" Instance="0x08" SubProgram="0x0" File="BiosDirL20_Typex68_0_8_0_ApcbRec.bin"/>
+    <IMAGE_ENTRY Type="0x68" Instance="0x09" SubProgram="0x0" File="BiosDirL20_Typex68_0_9_0_ApcbRec.bin"/>
+    <IMAGE_ENTRY Type="0x60" Instance="0x00" SubProgram="0x0" File="BiosDirL20_Typex60_0_0_0_Apcb.bin"/>
+    <IMAGE_ENTRY Type="0x60" Instance="0x01" SubProgram="0x0" File="BiosDirL20_Typex60_0_1_0_Apcb.bin"/>
+    <POINT_ENTRY Type="0x61" Address="0x0" Size="0x0" Destination="0x4000000"/>
+    <POINT_ENTRY Type="0x62" Address="0xD00000" Destination="0x76D00000" Size="0x300000">
+     <TypeAttrib Compressed="0x0" Copy="0x1" ReadOnly="0x0" RegionType="0x0" ResetImage="0x1"/>
+    </POINT_ENTRY>
+    <IMAGE_ENTRY Type="0x63" Instance="0x00" SubProgram="0x0" File="APOB_NV.bin"/>
+    <IMAGE_ENTRY Type="0x64" Instance="0x03" SubProgram="0x0" File="Appb_Ddr5_0x64_3_Rdimm_Imem1.ecsbin"/>
+    <IMAGE_ENTRY Type="0x65" Instance="0x03" SubProgram="0x0" File="Appb_Ddr5_0x65_3_Rdimm_Dmem1.ecsbin"/>
+    <IMAGE_ENTRY Type="0x64" Instance="0x04" SubProgram="0x0" File="Appb_Ddr5_0x64_4_Rdimm_Imem2.ecsbin"/>
+    <IMAGE_ENTRY Type="0x65" Instance="0x04" SubProgram="0x0" File="Appb_Ddr5_0x65_4_Rdimm_Dmem2.ecsbin"/>
+    <IMAGE_ENTRY Type="0x64" Instance="0x09" SubProgram="0x0" File="Appb_Ddr5_0x64_9_Rdimm_Imem1.ecsbin"/>
+    <IMAGE_ENTRY Type="0x65" Instance="0x09" SubProgram="0x0" File="Appb_Ddr5_0x65_9_Rdimm_Dmem1.ecsbin"/>
+    <IMAGE_ENTRY Type="0x64" Instance="0x0A" SubProgram="0x0" File="Appb_Ddr5_0x64_A_Rdimm_Imem2.ecsbin"/>
+    <IMAGE_ENTRY Type="0x65" Instance="0x0A" SubProgram="0x0" File="Appb_Ddr5_0x65_A_Rdimm_Dmem2.ecsbin"/>
+    <IMAGE_ENTRY Type="0x66" Instance="0x00" File="UcodePatch_B0.bin"/>
+    <IMAGE_ENTRY Type="0x66" Instance="0x01" File="UcodePatch_B1.bin"/>
+  </BIOS_DIR>
+</DIRS>
\ No newline at end of file
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/support/SupportedBuilds.json b/GenoaOpenBoardPkg/S8050BoardPkg/support/SupportedBuilds.json
new file mode 100644
index 0000000..b741ef9
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/support/SupportedBuilds.json
@@ -0,0 +1,15 @@
+{
+  "s8050": {
+    "platform": "S8050BoardPkg",
+    "sku": "80",
+    "soc": "Genoa",
+    "soc2": "Genoa",
+    "soc_family": "0x19",
+    "soc_sku": "Genoa",
+    "socket": "SP5",
+    "board": "S8050",
+    "build": "EXTERNAL",
+    "secure": "False",
+    "dir": "GenoaOpenBoardPkg"
+  }
+}
\ No newline at end of file
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/support/__init__.py b/GenoaOpenBoardPkg/S8050BoardPkg/support/__init__.py
new file mode 100644
index 0000000..913fef4
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/support/__init__.py
@@ -0,0 +1,6 @@
+"""
+*******************************************************************************
+ Copyright (C) 2021-2024 Advanced Micro Devices, Inc. All rights reserved.
+
+*******************************************************************************
+"""
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/support/projectpostbuild.py b/GenoaOpenBoardPkg/S8050BoardPkg/support/projectpostbuild.py
new file mode 100644
index 0000000..d05aa4e
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/support/projectpostbuild.py
@@ -0,0 +1,30 @@
+"""
+*******************************************************************************
+ Copyright (C) 2021-2024 Advanced Micro Devices, Inc. All rights reserved.
+
+*******************************************************************************
+"""
+
+import os
+
+def projectpostbuild():
+    # These will be set elsewhere with dbuild.py and can be removed when it
+    # replaces dbuild.cmd
+    os.environ["SOC_FAMILY"] = os.environ.get("SOC_FAMILY", "0x19")
+    os.environ["SOC_SKU"] = os.environ.get("SOC_SKU", "Genoa")
+    os.environ["SOC2"] = os.environ.get("SOC2", "Genoa")
+    os.environ["SOCKET"] = os.environ.get("SOCKET", "SP5")
+
+    workspace = os.environ['WORKSPACE']
+    build_output = os.environ['BUILD_OUTPUT']
+
+    os.environ['APCB_TOOL_TEMP_PATH'] = os.path.normpath(os.path.join(
+        workspace,
+        'AGCL-R/AgesaPkg/Addendum/Apcb/GenoaSp5Rdimm'
+    ))
+    os.environ['APCB_MULTI_BOARD_SUPPORT'] = '1'
+    os.environ['APCB_DATA_BOARD_DIR_LIST'] = 'GenoaCommon Onyx'
+    os.environ['CUSTOM_APCB_PATH'] = os.path.normpath(os.path.join(
+        build_output,
+        'Apcb'
+    ))
diff --git a/GenoaOpenBoardPkg/S8050BoardPkg/support/projectprebuild.py b/GenoaOpenBoardPkg/S8050BoardPkg/support/projectprebuild.py
new file mode 100644
index 0000000..4f28a9f
--- /dev/null
+++ b/GenoaOpenBoardPkg/S8050BoardPkg/support/projectprebuild.py
@@ -0,0 +1,16 @@
+"""
+*******************************************************************************
+ Copyright (C) 2021-2024 Advanced Micro Devices, Inc. All rights reserved.
+
+*******************************************************************************
+"""
+
+import os
+
+def projectprebuild():
+    # These will be set elsewhere with dbuild.py and can be removed when it
+    # replaces dbuild.cmd
+    os.environ["SOC_FAMILY"] = os.environ.get("SOC_FAMILY", "0x19")
+    os.environ["SOC_SKU"] = os.environ.get("SOC_SKU", "Genoa")
+    os.environ["SOC2"] = os.environ.get("SOC2", "Genoa")
+    os.environ["SOCKET"] = os.environ.get("SOCKET", "SP5")
diff --git a/MiTACCommonPkg/Library/PlatformHookLib/BasePlatformHookLibAST2600/BasePlatformHookLibAST2600.c b/MiTACCommonPkg/Library/PlatformHookLib/BasePlatformHookLibAST2600/BasePlatformHookLibAST2600.c
new file mode 100644
index 0000000..0737ecb
--- /dev/null
+++ b/MiTACCommonPkg/Library/PlatformHookLib/BasePlatformHookLibAST2600/BasePlatformHookLibAST2600.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2024 MiTAC Computing, Inc. All rights reserved.
+ *
+ */
+
+/* This file includes code originally published under the following license. */
+
+/** @file
+  Platform Hook Library instance.
+
+  Copyright (c) 2010, Intel Corporation. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include <Uefi.h>
+#include <Library/BaseLib.h>
+#include <Library/IoLib.h>
+#include <Library/PlatformHookLib.h>
+
+#ifndef SIO_IO_PORT_NUMBER
+  #define SIO_IO_PORT_NUMBER 0x2E
+#endif
+
+#define ASPEED2500_SIO_UART1      0x02
+#define ASPEED2500_SIO_UART2      0x03
+#define REG_LOGICAL_DEVICE        0x07
+#define ACTIVATE                  0x30
+#define BASE_ADDRESS_HIGH0        0x60
+#define BASE_ADDRESS_LOW0         0x61
+#define PRIMARY_INTERRUPT_SELECT  0x70
+#define INTERRUPT_TYPE            0x71
+#define ASPEED2500_SIO_UNLOCK     0xA5
+#define ASPEED2500_SIO_LOCK       0xAA
+#define COM1_BASE                 0x3F8
+#define COM2_BASE                 0x2F8
+
+
+typedef struct {
+  UINT8   Index;
+  UINT8   Data;
+} SIO_REG_TABLE;
+
+STATIC  SIO_REG_TABLE  mASPEED2500Table [] = {
+  { REG_LOGICAL_DEVICE,         ASPEED2500_SIO_UART1  },
+  { ACTIVATE,                   0x01                  },
+  { BASE_ADDRESS_HIGH0,         (COM1_BASE >> 8)      }, // Set Base Address MSB
+  { BASE_ADDRESS_LOW0,          (COM1_BASE & 0x00FF)  }, // Set Base Address LSB
+  { PRIMARY_INTERRUPT_SELECT,   0x04                  }, // COMA IRQ routing
+  { INTERRUPT_TYPE,             0x01                  }, // COMA Interrupt Type
+  { REG_LOGICAL_DEVICE,         ASPEED2500_SIO_UART2  },
+  { ACTIVATE,                   0x01                  },
+  { BASE_ADDRESS_HIGH0,         (COM2_BASE >> 8)      }, // Set Base Address MSB
+  { BASE_ADDRESS_LOW0,          (COM2_BASE & 0x00FF)  }, // Set Base Address LSB
+  { PRIMARY_INTERRUPT_SELECT,   0x03                  }, // COMB IRQ routing
+  { INTERRUPT_TYPE,             0x01                  }  // COMB Interrupt Type
+};
+
+
+/**
+  Performs platform specific initialization required for the CPU to access
+  the hardware associated with a SerialPortLib instance.  This function does
+  not intialize the serial port hardware itself.  Instead, it initializes
+  hardware devices that are required for the CPU to access the serial port
+  hardware.  This function may be called more than once.
+
+  @retval RETURN_SUCCESS       The platform specific initialization succeeded.
+  @retval RETURN_DEVICE_ERROR  The platform specific initialization could not be completed.
+
+**/
+RETURN_STATUS
+EFIAPI
+PlatformHookSerialPortInitialize (
+  VOID
+  )
+{
+  UINT8                               Index;
+
+  IoWrite8 (SIO_IO_PORT_NUMBER, ASPEED2500_SIO_UNLOCK);                  // Send 0xA5 twice to enter configuration mode
+  IoWrite8 (SIO_IO_PORT_NUMBER, ASPEED2500_SIO_UNLOCK);                  //
+
+  for (Index = 0; Index < sizeof (mASPEED2500Table)/sizeof (SIO_REG_TABLE); Index++) {
+    IoWrite8 (SIO_IO_PORT_NUMBER, mASPEED2500Table[Index].Index);
+    IoWrite8 (SIO_IO_PORT_NUMBER+1, mASPEED2500Table[Index].Data);
+  }
+
+  IoWrite8 (SIO_IO_PORT_NUMBER, ASPEED2500_SIO_LOCK);                  // Exit configuration mode
+
+  return RETURN_SUCCESS;
+}
diff --git a/MiTACCommonPkg/Library/PlatformHookLib/BasePlatformHookLibAST2600/BasePlatformHookLibAST2600.inf b/MiTACCommonPkg/Library/PlatformHookLib/BasePlatformHookLibAST2600/BasePlatformHookLibAST2600.inf
new file mode 100644
index 0000000..f33945a
--- /dev/null
+++ b/MiTACCommonPkg/Library/PlatformHookLib/BasePlatformHookLibAST2600/BasePlatformHookLibAST2600.inf
@@ -0,0 +1,46 @@
+#;*****************************************************************************
+#; Copyright (C) 2017-2022 Advanced Micro Devices, Inc. All rights reserved.
+#;
+#;******************************************************************************
+#
+# This file includes code originally published under the following license.
+#
+## @file
+#  Platform Hook Library instance.
+#
+#  Copyright (c) 2010, Intel Corporation. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution. The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+##
+
+[Defines]
+  INF_VERSION                    = 0x00010005
+  BASE_NAME                      = BasePlatformHookLibAST2600
+  FILE_GUID                      = 33417fce-e0fe-486f-923e-a6b5e917a129
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = PlatformHookLib
+
+[Sources]
+  BasePlatformHookLibAST2600.c
+
+[Packages]
+  MdePkg/MdePkg.dec
+  MdeModulePkg/MdeModulePkg.dec
+[LibraryClasses]
+  BaseLib
+  PcdLib
+  IoLib
+  PciSegmentLib
+[FixedPcd]
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSerialRegisterBase
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSerialUseMmio
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSerialClockRate
+  gEfiMdeModulePkgTokenSpaceGuid.PcdSerialBaudRate
-- 
2.34.1

